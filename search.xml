<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[仙居之旅]]></title>
    <url>%2F2018%2F05%2F01%2F501%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F04%2F28%2F428_2%2F</url>
    <content type="text"><![CDATA[title: 字符串date: 2018-04-28 14:14:21tags: [字符串] categories: algorithm替换空格题目描述 请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 代码123456789101112131415public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; String strT = str.toString(); String temp = ""; char[] ch = strT.toCharArray(); for(int i = 0; i &lt; ch.length; i++)&#123; if(ch[i] == ' ')&#123; temp = temp + "%20"; &#125;else&#123; temp = temp + ch[i]; &#125; &#125; return temp; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F04%2F28%2F428_1%2F</url>
    <content type="text"><![CDATA[title: 递归date: 2018-04-28 10:14:21tags: [递归] categories: algorithm斐波那契数列题目描述 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39 代码1234567891011public class Solution &#123; public int Fibonacci(int n) &#123; if(n == 0 )&#123; return 0; &#125;else if(n == 1)&#123; return 1; &#125;else &#123; return Fibonacci(n-1)+Fibonacci(n-2); &#125; &#125;&#125; 跳台阶题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 代码1234567891011public class Solution &#123; public int JumpFloor(int target) &#123; if(target == 1)&#123; return 1; &#125;else if(target == 2)&#123; return 2; &#125;else&#123; return JumpFloor(target-2)+JumpFloor(target-1); &#125; &#125;&#125; More我记得大三上算法课听过这个题，只不过不会，一直不会，今天写第一次就过了。我擦类。。。。。。。。 变态跳台阶题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 代码123456789public class Solution &#123; public int JumpFloorII(int target) &#123; if( target == 1)&#123; return 1; &#125;else&#123; return 2 * JumpFloorII(target - 1); &#125; &#125;&#125; 思路因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级，跳1级，剩下n-1级，则剩下跳法是f(n-1)，跳2级，剩下n-2级，则剩下跳法是f(n-2)，所以f(n)=f(n-1)+f(n-2)+…+f(1)，因为f(n-1)=f(n-2)+f(n-3)+…+f(1)，所以f(n)=2*f(n-1) 矩形覆盖题目描述 我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 代码12345678910111213public class Solution &#123; public int RectCover(int target) &#123; if(target == 0)&#123; return 0; &#125;else if(target == 1)&#123; return 1; &#125;else if(target == 2)&#123; return 2; &#125;else&#123; return RectCover(target-1)+RectCover(target-2); &#125; &#125;&#125; 思路其实就是Fibonacci序列的等价转换。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F04%2F28%2F428%2F</url>
    <content type="text"><![CDATA[title: 二维数组中的查找date: 2018-04-28 8:44:21tags: [数组] categories: algorithm题目描述 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 代码123456789101112131415161718public class Solution &#123; public boolean Find(int target, int [][] array) &#123; int rowLength = array.length; int columnLength = array[0].length; for(int i = rowLength-1, j = 0; i&gt;=0 &amp;&amp; j&lt;columnLength; )&#123; if(array[i][j] &lt; target)&#123; j++; &#125; else if(array[i][j] &gt; target)&#123; i--; &#125; else if(array[i][j] == target)&#123; return true; &#125; &#125; return false; &#125;&#125; 思路选择左下角开始，如果target比当前节点大，则向右，小，向上。 坑1 如何判断一个二位数组为空，一是数组首地址是否为空，二是是否为{}，也就是array.length==0的情况，三是\left\left\right\right，这时array.length=1，但是array[0].length==0。满足任意一个条件就可以返回false了。if(array==null||array.length==0||(array.length==1&amp;&amp;array[0].length==0)) return false;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F04%2F27%2F427data%2F</url>
    <content type="text"><![CDATA[title: SQL入门date: 2018-04-27 15:37:21tags: [SQL] categories: 数据操作语言（DML） select: 从数据库中获取数据 update： 更新数据库表中的数据 delete： 从数据库中删除数据 insert into : 向数据库中插入数据 数据定义语言（DDL）用于创建和删除表格，也可以定义索引（键），规定表之间的链接，以及施加表间的约束。 create database : 创建新数据库 alter database : 修改数据库 create table ： 创建新表 alter table : 变更（改变）数据库表 drop table : 删除表 create index ： 创建索引（搜索键） drop index : 删除索引 语句select语句 select 列名称 from 表名称 select * from 表名称 select distinct去重复 select distinct 列名称 from 表名称 where子句如需有条件地从表中选取数据，可将where子句添加到select语句。 select 列名称 from 表名称 where 列 运算符 值运算符： =, &lt;&gt;, &gt;, &lt;, &gt;=, &lt;=, between, like AND和OR运算符可在where子语句中把两个或多个条件结合起来。 select * from Persons where FirstName=’Thomas’ and LastName=’Carter’ order by语句order by 语句用于根据指定的列对结果集进行排序。默认升序，降序用desc。 select Company，OrderNumber from Orders order by Company desc select Company, ORderNumber from orders order by Company desc, orderNumber asc desc: descend; asc: ascend insert into语句插入新的行。 insert into 表名称 values(值1， 值2， …) insert into table_name(列1，列2，…) values(值1，值2，…) insert into Persons(lastName, Address) values (‘Wilson’, ‘Chapms-Elysees’) update语句 update 表名称 set 列名称 = ‘新值’ where 列名称 = 某值 delete语句删除表中的行 delect from 表名称 where 列名称 = 值删除所有行 delect from table_name limit语句返回表中头几行 select * from table_name limit number like操作符like操作符用于在where子句中搜索列中的指定模式。 select * from Persons where city like ‘N%’%可用于定义通配符（模式中缺少的字母）， NOT指代不包含 select * from Persons where city not like ‘%lon%’ SQL通配符通配符必须与Like运算符一起使用 通配符 | 描述% | 代替一个或多个字符 | 仅代替一个字符 in select * from table_name where 列 in (值1，值2)]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F04%2F27%2F427%2F</url>
    <content type="text"><![CDATA[title: 数组中重复的数字 &amp;&amp; 构建乘积数组date: 2018-04-27 10:37:21tags: [数组] categories: algorithm题目描述 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 代码1234567891011121314151617181920212223public class Solution &#123; // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation; // Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++ // 这里要特别注意~返回任意重复的一个，赋值duplication[0] // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false public boolean duplicate(int numbers[],int length,int [] duplication) &#123; boolean[] temp = new boolean[length]; for(int i = 0; i&lt;length; i++)&#123; int tempInt = numbers[i]; if(!temp[tempInt])&#123; temp[tempInt] = true; &#125;else&#123; duplication[0] = tempInt; return true; &#125; &#125; return false; &#125;&#125; 思路用一个Boolean数组判断数字有没有重复过。 坑1 Boolean数组默认初始值是false 题目描述 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法 代码```javaimport java.util.ArrayList;public class Solution { public int[] multiply(int[] A) { int aLength = A.length; int[] value = new int[aLength]; for(int i = 0 ; i]]></content>
  </entry>
  <entry>
    <title><![CDATA[按之字形顺序打印二叉树]]></title>
    <url>%2F2018%2F04%2F26%2F426_1%2F</url>
    <content type="text"><![CDATA[题目描述 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 代码12345678910public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** 队列LinkedList完成层序遍历，用end记录每层结点数目*/public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123; LinkedList&lt;TreeNode&gt; list = new LinkedList&lt;&gt;(); ArrayList layer = new ArrayList(); ArrayList&lt;ArrayList&lt;Integer&gt;&gt; last = new ArrayList&lt;&gt;(); int start = 0; int end = 1; int count = 1; list.add(pRoot); if(pRoot == null)&#123; return last; &#125; while(! list.isEmpty())&#123; TreeNode t = list.remove(); layer.add(t.val); start++; if(t.left != null)&#123; list.add(t.left); &#125; if(t.right != null)&#123; list.add(t.right); &#125; if(start == end)&#123; start = 0; end = list.size(); if( count % 2 == 0)&#123; Collections.reverse(layer); last.add(layer); &#125;else&#123; last.add(layer); &#125; layer = new ArrayList(); count++; &#125; &#125; return last; &#125;&#125; 思路这个一个层次遍历的应用，中间需要记录每一行的开始（start）和结束（end），来确定一层输出一行。 坑1 我最开始的想法是每一个节点对应一个数字（行号）确定他是在哪一行，等到对应节点的行号与下一个节点不一样的时候，就换行。与上面的代码区别是多了一个ArrayList，记录好多不需要的信息，浪费了。 知识点1 层次遍历 层次遍历，底层就是一个队列。算法思路是： 先将二叉树头节点入队列，然后出队列，访问该节点，如果它有左子树，则将左子树根节点入队，如果它有右子树，则将右子树根节点入队。然后出队列，对出队列节点访问，如此反复，直到队列为空为止。 More代码中是通过LinkedList模拟队列的，Java把队列，栈等数据结构封装的很好，但是最好还是要自己来理解实现一下这些底层。最近有看redis，里面很多操作的底层也是这些基础。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遍历二叉树]]></title>
    <url>%2F2018%2F04%2F26%2F426%2F</url>
    <content type="text"><![CDATA[树定义12345678public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 先序遍历先序遍历递归12345public void preorder(TreeNode root)&#123; System.out.print(root); preorder(root.left); preorder(root.right);&#125; 先序遍历非递归12345678910111213141516public void preorder2(TreeNode root)&#123; LinkedList&lt;TreeNode&gt; list = new LinkedList&lt;&gt;(); while(root != null || !list.isEmpty())&#123; if(root != null)&#123; System.out.print(root); list.push(root); root = root.left; &#125; if(!list.isEmpty())&#123; root = list.pop(); root = root.right(); &#125; &#125; &#125; 中序遍历中序遍历递归12345public void inorder(TreeNode root)&#123; inorder(root.left); System.out.print(root); inorder(root.right);&#125; 中序遍历非递归123456789101112131415public void inorder2(TreeNode root)&#123; LinkedList&lt;TreeNode&gt; list = new LinkedList&lt;&gt;(); while(root != null || !list.isEmpty())&#123; if(root != null)&#123; list.push(root); root = root.left; &#125; if(!list.isEmpty())&#123; root = list.pop(); System.out.print(root); root = root.right(); &#125; &#125;&#125; 后序遍历后序遍历递归12345public void postorder(TreeNode root)&#123; postorder(root.left); postorder(root.right); System.out.print(root);&#125; 后序遍历非递归12345678910111213141516171819202122public void postorder2(TreeNode root)&#123; LinkedList&lt;TreeNode&gt; list = new LinkedList&lt;&gt;(); LinkedList&lt;TreeNode&gt; list2 = new LinkedList&lt;&gt;(); while(root != null || !list.isEmpty()) &#123; while (root != null) &#123; list.push(root); list2.push(new Integer(0)); root = root.left; &#125; while (!list.isEmpty() &amp;&amp; list2.peek().equals(1)) &#123; list2.pop(); System.out.print(list.pop()); &#125; if (!list.isEmpty()) &#123; list2.pop(); list2.push(new Integer(1)); root = list.peek(); root = root.right; &#125; &#125; &#125; 层次遍历12345678910111213141516171819202122public void level(TreeNode root)&#123; int start = 0; int end = 1; LinkedList list = new LinkedList(); list.add(root); while(!list.isEmpty())&#123; TreeNode t = list.remove(); System.out.print(t.val); start++; if(t.left != null)&#123; list.add(t.left); &#125; if(t.right != null)&#123; list.add(t.right); &#125; if(start == end)&#123; start = 0; end = list.size()； &#125; &#125;&#125; More/(ㄒoㄒ)/~~ /(ㄒoㄒ)/~~]]></content>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的镜像]]></title>
    <url>%2F2018%2F04%2F25%2F425%2F</url>
    <content type="text"><![CDATA[题目描述 操作给定的二叉树，将其变换为源二叉树的镜像。输入描述:二叉树的镜像定义：源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 代码1234567891011/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/ 123456789101112131415public class Solution &#123; public void Mirror(TreeNode pRoot) &#123; Mirror2(root); &#125; public void Mirror2(TreeNode t)&#123; TreeNode temp = null; if(t != null)&#123; temp = t.left; t.left = t.right; t.right = temp; Mirror2(t.left); Mirror2(t.right); &#125;&#125; 思路将左右两个子树交换，递归的调用 坑1 开始的时候将Mirror2(t.left)，Mirror2(t.right)写在了外面，这样的话，会报空，因为if走完后，接着走这两条。 More感觉人生第一次用递归一次写完这个题目，并提交成功，吼开心。。。。。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对称的二叉树]]></title>
    <url>%2F2018%2F04%2F24%2F424_2%2F</url>
    <content type="text"><![CDATA[题目描述 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 代码123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 1234567891011121314151617181920212223242526272829public class Solution &#123; boolean isSymmetrical(TreeNode pRoot) &#123; TreeNode node = getMirror(pRoot); return isSymmetrical(pRoot,node); &#125; boolean isSymmetrical(TreeNode pRoot,TreeNode node) &#123; if(pRoot == null &amp;&amp; node == null)&#123; return true; &#125;else if(pRoot == null || node == null)&#123; return false; &#125; if(pRoot.val == node.val)&#123; return isSymmetrical(pRoot.left,node.left)&amp;&amp;isSymmetrical(pRoot.right,node.right); &#125; return false; &#125; TreeNode getMirror(TreeNode pRoot)&#123; if (pRoot == null) &#123; return null; &#125; TreeNode root = new TreeNode(pRoot.val); root.right = getMirror(pRoot.left); root.left = getMirror(pRoot.right); return root; &#125;&#125; 思路将树copy一份并求出其镜像树（将每个结点的左右子树交换），比较原树和镜像树的每个节点，如果全部一样，则是镜像树 坑1 getMirror()函数也是递归定义。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把二叉树打印成多行]]></title>
    <url>%2F2018%2F04%2F24%2F424%2F</url>
    <content type="text"><![CDATA[题目描述 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 代码1234567891011public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334/** 队列LinkedList完成层序遍历，用end记录每层结点数目*/public class Solution &#123; ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); if(pRoot == null)&#123; return result; &#125; Queue&lt;TreeNode&gt; layer = new LinkedList&lt;TreeNode&gt;(); ArrayList&lt;Integer&gt; layerList = new ArrayList&lt;Integer&gt;(); layer.add(pRoot); int start = 0, end = 1; while(!layer.isEmpty())&#123; TreeNode cur = layer.remove(); layerList.add(cur.val); start++; if(cur.left!=null)&#123; layer.add(cur.left); &#125; if(cur.right!=null)&#123; layer.add(cur.right); &#125; //判断start是否end,来确定一层一行 if(start == end)&#123; end = layer.size(); start = 0; result.add(layerList); layerList = new ArrayList&lt;Integer&gt;(); &#125; &#125; return result; &#125;&#125; 思路这个一个层次遍历的应用，中间需要记录每一行的开始（start）和结束（end），来确定一层输出一行。 坑1 我最开始的想法是每一个节点对应一个数字（行号）确定他是在哪一行，等到对应节点的行号与下一个节点不一样的时候，就换行。与上面的代码区别是多了一个ArrayList，记录好多不需要的信息，浪费了。 知识点1 层次遍历 层次遍历，底层就是一个队列。算法思路是： 先将二叉树头节点入队列，然后出队列，访问该节点，如果它有左子树，则将左子树根节点入队，如果它有右子树，则将右子树根节点入队。然后出队列，对出队列节点访问，如此反复，直到队列为空为止。 More代码中是通过LinkedList模拟队列的，Java把队列，栈等数据结构封装的很好，但是最好还是要自己来理解实现一下这些底层。最近有看redis，里面很多操作的底层也是这些基础。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的下一个结点]]></title>
    <url>%2F2018%2F04%2F23%2F424_1%2F</url>
    <content type="text"><![CDATA[题目描述 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 代码12345678910public class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213141516public class Solution &#123; TreeLinkNode GetNext(TreeLinkNode node) &#123; if(node==null) return null; if(node.right!=null)&#123; //如果有右子树，则找右子树的最左节点 node = node.right; while(node.left!=null) node = node.left; return node; &#125; while(node.next!=null)&#123; //没右子树，则找第一个当前节点是父节点左孩子的节点 if(node.next.left==node) return node.next; node = node.next; &#125; return null; //退到了根节点仍没找到，则返回null &#125;&#125; 思路 坑1 对应图片中的b）开始没有思考的那么透彻，像j节点，和M节点开始都是迷糊的。 知识点1 中序遍历 如果二叉树为空树，则什么都不做；否则： 先序遍历左子树 访问根节点 先序遍历右子树 More图片是出自小河沟大河沟]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重建二叉树]]></title>
    <url>%2F2018%2F04%2F20%2F420_1%2F</url>
    <content type="text"><![CDATA[题目描述 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 代码123456789/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */ 12345678910111213141516171819202122232425public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; TreeNode root=reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1); return root; &#125; //前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125; private TreeNode reConstructBinaryTree(int [] pre,int startPre,int endPre,int [] in,int startIn,int endIn) &#123; //如果树为空 if(startPre&gt;endPre||startIn&gt;endIn) return null; //根据先序遍历确定root节点 TreeNode root=new TreeNode(pre[startPre]); //递归：分别确定左子树和右子树 for(int i=startIn;i&lt;=endIn;i++) //确定子树的root节点 if(in[i]==pre[startPre])&#123; //左 root.left=reConstructBinaryTree(pre,startPre+1,startPre+i-startIn,in,startIn,i-1); //右 root.right=reConstructBinaryTree(pre,i-startIn+startPre+1,endPre,in,i+1,endIn); break; &#125; return root; &#125;&#125; 思路根据先序确定根节点，查找对应中序中位置，在中序位置左边为左子树，右边为右子树，递归调用。 坑1 已经忘了如何根据前序和中序确定一棵树 知识点1 先序遍历（前序遍历） 如果二叉树为空树，则什么都不做；否则： 访问根节点 先序遍历左子树 先序遍历右子树 2 中序遍历 如果二叉树为空树，则什么都不做；否则： 先序遍历左子树 访问根节点 先序遍历右子树 3 后续遍历 如果二叉树为空树，则什么都不做；否则： 先序遍历左子树 先序遍历右子树 访问根节点 More回看树，其实树里有好多东西的]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表总结]]></title>
    <url>%2F2018%2F04%2F20%2F420%2F</url>
    <content type="text"><![CDATA[链表是一种递归的数据机构，它或者为空(null)，或者是指向一个节点(node)的引用，该节点含有一个泛型的元素和一个指向另一条链表的引用。 抽象数据类型1234567891011/*** public class ListNode &#123;* Object val;* ListNode next = null;** ListNode() &#123; &#125;* ListNode(Object val) &#123;* this.val = val;* &#125;* &#125;*/ 上述代码定义了ListNode对象，有两个实例变量，val和next，val类型是任何你希望的数据类型（这里用了Object），next指下一个节点（默认为null）。这个定义可能会有写费解，因为这个是一个递归的数据结构。 链表的操作表头插入节点123ListNode oldfirst = first;first = new ListNode();first.next = oldfirst; 表头删除节点1first = first.next; 表尾插入节点123oldlast = last;last = new ListNode();oldlast.next = last; 如何学好链表可以和这位学下。也可以像算法第四版用链表实现一个栈、队列。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表中环的入口结点]]></title>
    <url>%2F2018%2F04%2F19%2F419_1%2F</url>
    <content type="text"><![CDATA[题目描述 一个链表中包含环，请找出该链表的环的入口结点。 代码12345678910/* public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/ 123456789101112131415import java.util.ArrayList;public class Solution &#123; public ListNode EntryNodeOfLoop(ListNode pHead) &#123; ArrayList&lt;ListNode&gt; list = new ArrayList&lt;ListNode&gt;(); if(pHead == null) return null; while(!list.contains(pHead))&#123; list.add(pHead); pHead = pHead.next; if(pHead == null) return null; &#125; return pHead; &#125;&#125; 思路遍历一遍链表，并将每个节点存入ArrayList,如果遍历过程中发现ArrayList已经存在当前节点，那说明这个就是我们要找的节点 坑1 题目说是链表有环，但是提交代码后，发现要判断这个链表有没有环。 知识点1 了解下ArrayList的contain方法是怎么实现的 More看别人提交的代码，像是在解一道数学题，首先你要设x=2y，然后回推，效率是高的，复杂度也低，但是耗脑子，可以学习一波。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从尾到头打印链表]]></title>
    <url>%2F2018%2F04%2F19%2F419%2F</url>
    <content type="text"><![CDATA[题目描述 输入一个链表，从尾到头打印链表每个节点的值。 代码1234567891011/*** public class ListNode &#123;* int val;* ListNode next = null;** ListNode(int val) &#123;* this.val = val;* &#125;* &#125;**/ 123456789101112131415161718192021import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; //存取链表中的数据 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //存取list的反向数据 ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); //如果为空，啥也不做 if(listNode == null) &#123; return list1; &#125; while(listNode!=null) &#123; list.add(listNode.val); listNode = listNode.next; &#125; for(int i = list.size()-1;i&gt;=0;i--) &#123; list1.add(list.get(i)); &#125; return list1; &#125;&#125; 思路链表读取存储到ArrayList中，然后再从ArrayList反向读取存储到另一个ArrayList（就是栈的操作） 坑1 我不是很确定空的ArrayList输出是什么，是”[]”; 知识点1 链表]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除链表中重复的结点]]></title>
    <url>%2F2018%2F04%2F18%2F418%2F</url>
    <content type="text"><![CDATA[题目描述 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 代码12345678910/* public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/ 12345678910111213141516171819202122public class Solution &#123; public ListNode deleteDuplication(ListNode pHead) &#123; ListNode result; ListNode temp = pHead; ListNode index = new ListNode(1); index.next = pHead; result = index; while (temp != null) &#123; if (temp.next != null &amp;&amp; temp.next.val == temp.val) &#123; while (temp.next != null &amp;&amp; temp.next.val == temp.val) &#123; temp = temp.next; &#125; temp = temp.next; index.next = temp; &#125; else &#123; index = index.next; temp = temp.next; &#125; &#125; return result.next; &#125;&#125; 坑1 第一次提交删除了重复的节点，题目要求是所有重复的节点，一个也不留2 对于Java中引用理解需要加深3 链表的操作需要了解，这里尽管只有删除 知识点1 链表1.1 数据结构1.2 操作 2 Java中的引用]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顺时针打印矩阵]]></title>
    <url>%2F2018%2F04%2F17%2F417%2F</url>
    <content type="text"><![CDATA[题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 代码123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); //判断matrix是否为空 if(matrix == null || matrix.length == 0) return list; //matrix的行 int row = matrix.length; //matrix的列 int col = matrix[0].length; //方便矩阵的遍历 int rowStart = 0; int rowEnd = row - 1; int colStart = 0; int colEnd = col - 1; while(colStart &lt;= colEnd &amp;&amp; rowStart &lt;= rowEnd) &#123; for(int i = colStart; i &lt;= colEnd; i++) list.add(matrix[rowStart][i]); for(int i = rowStart+1; i &lt;= rowEnd; i++) list.add(matrix[i][colEnd]); //防止重复遍历 if(rowStart != rowEnd) &#123; for(int i = colEnd-1; i &gt;= colStart; i--) list.add(matrix[rowEnd][i]); &#125; //防止重复遍历 if(colStart != colEnd) &#123; for(int i = rowEnd-1; i &gt; rowStart; i--) list.add(matrix[i][colStart]); &#125; colStart++; colEnd--; rowStart++; rowEnd--; &#125; return list; &#125;&#125; 坑1 对于向量，从上到下（从左往右）和从下到上（从右往左）只要遍历一次。如：1int[][] a = &#123;&#123;1&#125;,&#123;2&#125;,&#123;3&#125;,&#123;4&#125;,&#123;5&#125;&#125; 2 很多边界例子不会考虑。 知识点1 高维数组1.1 如何定义一个二维（更高维）的数组123int[][] a = &#123;&#123;1,2,&#125;,&#123;3,4&#125;&#125;;int[][][] three = &#123;&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;,&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;&#125;;int[][] b = new int[2][2]; 1.2数组的长度12int row = matrix.length;int col = matrix[0].length; 1.3 java Arrays.deepToString()函数将高维数组字符串化 今天人生第一次来做这种题目，说实话不会做，做了会有很多错，尽管看起来很简单。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这几天]]></title>
    <url>%2F2018%2F01%2F22%2F1.22%2F</url>
    <content type="text"><![CDATA[好多天没有来玩博客，Markdown的语法也忘了，hexo的命令也忘了，导师的教我写的东西，一个月没碰了，啥啥啥都忘了。。。。 前几天无聊看了一波python文档，把廖老师写的文档和《简明Python教程》过了一遍，然后发现这是一个神奇的世界。 恩，写这个文章，其实也不是说我要介绍我这天的心得体会，就只是来冒个泡，写文章真的需要坚持，如果你不是职业的话，而且，我发现的我不知道写啥，内心啥也木有， 这几天看了一波吐槽大会，interesting，哈哈哈哈哈哈哈哈，然后还去下了一波《手把手教你脱口秀》，好有意思。 我还准备买个陶笛，人生最大的梦想，懂一波音乐。 这几天，大家都放假，氛围特别浓重，说实话，我都给自己放一个月了。。。。 不知道自己写了什么，就当记录一下吧，byebye。。。。。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多个电脑一起写blog]]></title>
    <url>%2F2018%2F01%2F13%2Fblog%2F</url>
    <content type="text"><![CDATA[你是不是也有这样子的问题，如果台式机可以写博客上传，那笔记本想写怎么办呢？我来告诉你。 传送门送上：1，2第一篇的文章比较短，但是就是精华，第二篇，有部分图文，会给你一些更直观的参考。 我呢，还是给大家一些建议 不要怕出错，说实话，对于一个小白来说，什么也不懂，什么是git啊，没关系，不要担心，要相信自己。 尽管你可能不懂git,可是这玩意还是不得不学的额，常见的命令 git pull origin hexo: 本机同步GitHub里的文章 git push origin hexo: 上传文章到GitHub]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的使用]]></title>
    <url>%2F2018%2F01%2F13%2Fnote%2F</url>
    <content type="text"><![CDATA[配置用户名和Email$ git config –global user.name “Your Name”$ git config –global user.email “email@example.com” 创建版本库初始化一个Git仓库，使用git init命令。添加文件到Git仓库，分两步： 第一步，使用命令git add ，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit -m “”，完成。 vim的使用i 进入输入模式ESC 退出输入模式，进入命令模式:wq 保存修改并退出vim 状态的查看和比较 比较 git diff 查看 git status 文件名 版本回退 查看历史 git log/git log –pretty=online当前版本用HEAD表示，HEAD^表示上一个版本，HEAD^^表示上上版本，HEAD~100表示上100个版本 回退到当前版本的上一个版本 git reset –hard HEAD^当你回退到以前版本，那当前版本会不见，可以使用 git reset –hard (commit id)来恢复 记录执行的每一次命令 git reflog通过此条命令可以查看到各个版本commit id HEAD指向当前版本git log 查看提交历史git reflog 查看命令历史 工作区和暂存区 工作区(Working Directory)就是当前目录 版本库(Repository)工作区中隐藏目录.git,Git的版本库版本库中有：暂存区、第一个分支master、指向master的一个指针HEAD 暂存区(Stage)把文件往Git版本库里添加的时候，分为两步第一步：git add，意义是把文件添加到暂存区第二步: git commit,意义是将暂存区的所有内容提交到当前分支开始默认我们在master分支 Git是如何跟踪修改的：每次修改，如果不add到暂存区，那就不会加入到commit中。 撤销和修改命令是：git checkout – filename file自修改后还没有被放到暂存区，使用命令后，返回版本库的状态 file已经添加到了暂存区，又作了修改，使用命令后，返回暂存区的状态总之，是文件返回最近一次git commit 或 git add 的状态 命令：git reset HEAD file指的是把暂存区的修改撤销，回到工作区的版本git reset 既可以回退版本，也可以把暂存区的修改回退到工作区。 总结： 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 删除文件将已经提交到版本库的文件删除，需要同步git git rm file git commit -m “”如果是误删git checkout – file 添加远程仓库 要关联一个远程库，使用命令**git remote add origin git@server-name:path/repo-name.git; 关联后，使用命令git push -u origin master 第一次推送master分支的所有内容; 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改; Tipsssh:是一个安全协议，git支持git协议。第一次使用ssh的时候，需要设置公钥和私钥，命令是 ssh-keygen -t rsa -C “youremail@example.com”对应的在用户主目录中会生成.ssh目录，目录中有id_rsa和id_rsa.pub两个文件 clone远程库命令是git clone git@server-name:path/repo-name.gitgit支持多种协议，包括https，ssh 等等 创建与合并分支 git checkout -b dev:创建了dev分支命令等同于：git branch dev ; git checkout dev git branch:查看当前分支，罗列出所有分支 git merge dev:将dev分支的工作成果合并到当前分支上 git branch -d dev:删除dev分支 解决冲突当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。用git log –graph命令可以看到合并图。好看一点用git log –graph –pretty=oneline –abbrev -commit 分支策略 master分支用来发布新版本，平时不东 dev分支是用来干活的，干完活和master合并 每个团队成员创建自己的分支，是不是和dev分支合并 合并时，默认是fast forward合并，合并后删除分支后看不出是合并的，会丢失信息，加上–nn-ff参数就可以使用普通模式合并 Bug分支当我们遇到bug需要修复，手头的任务又没有做完，我们可以使用git stash来保护现场，类似于进程中断。当我们修复好bug后，我们可以用git stash list查看工作现场。 git stash git stash list git stash apply:恢复现场，但不删除stash git stash drop:删除stash git stash pop:等于上两步 feature分支开发一个新feature，最好创建一个分支；如果要丢弃一个没有被合并过的分支，可以通过git branch -D name 强行删除。 多人协作 git remote :用于查看远程库的信息 git remote -v :用于查看远程库的详细信息 git push origin master/dev :master分支需要和远程同步，dev分支也一样，bug分支不需要，feature分支看情况]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Me]]></title>
    <url>%2F2018%2F01%2F13%2FMe%2F</url>
    <content type="text"><![CDATA[Hey,大家好！！！你们可以叫我echo，这是三毛的英文名，感觉三毛和荷西的爱情很酷，所以我随了三毛。]]></content>
  </entry>
  <entry>
    <title><![CDATA[echo xi]]></title>
    <url>%2F2018%2F01%2F13%2Ffirst%2F</url>
    <content type="text"><![CDATA[xixiOK? 你知道吗？ 我看别人的博客都是名言警句随口来，我呢，刚刚憋了许久，木有啊！！ /(ㄒoㄒ)/~~]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何建立一个独立博客]]></title>
    <url>%2F2018%2F01%2F12%2Fhexo-github%2F</url>
    <content type="text"><![CDATA[我来猜一猜你为什么要建博客：装逼，找个地方发泄，无聊。。。如果不对，你可以留言告诉我 ^_^ 前言如果你是小白，那你肯定会受好多挫，你可以百度也可以Google，当然我希望什么也不要遇到，因为我会告诉你所有可能的错，别问我为什么 o(╥﹏╥)o what you need ? git hexo github 这三个是啥呢？github，类似于一个服务器，这样别人就可以在网上找到你的博客，当然你也可以自己买服务器。hexo，模板，就是博客显示页面的样子，有好多好人已经写好了很多好看的模板，你挑一个喜欢的，当然你也可以自己写！git，上传工具，就是把你写好的东西，上传到网上。 安装gitGit下载:下载完就可以安装了，一路next 结束安装，检查自己有木有成功，Win+R，cmd 如果看见版本号，就成功啦！！是不是很惊喜，很开心，吼简单哦！！ 安装hexo恩~，这个地方有点烦的，请注意！！！官网：官方文档：很详细，可以仔细学习一波。我呢，就给一些注意事项 先要安装Node.js 在任何地方(比如桌面)右击，点击 git bash here，在输入 npm install -g hexo-cli 回车，输入画面如图： hexo是使用Markdown解析文章的，那标记后面需要一个空格图片中每个key后面都有空格，图中的绿色方框，有点大小不一，但都代表一个空格 最后写完文章部署的时候，可以用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d一条命令我在写这个文档的时候，也重看了一边官网，虽说很详细，带我不想看啊，好烦啊，好烦啊，与木有这种感觉，o(╥﹏╥)o GitHub这个真的是一个好神奇的地方，抄作业的好地方，代码不会写，来抄一波，没有灵感，来搜一波，比什么百度靠谱多了。来一个传送门，这篇文章在这儿写的很详细贴心，最主要页面看的不是那么难看。 OK我想你已经完成你的博客的建立了，是不是很happy，我当时就老happy了，可是，记住写博客还是一件很艰难的事，时间久了，人就懒了，就不写了。当然，我知道说的不是你，(#^.^#)]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown的使用]]></title>
    <url>%2F2018%2F01%2F12%2FMarkdown%2F</url>
    <content type="text"><![CDATA[Markdown的好处 比纯文本排版显示的好看 比Word排版显示简单 学起来简单 学习资料 Markdown中文版语法说明 博客1 博客2 建议 不用什么语法都学，学几个常用的就可以，比如标题，粗体，斜体。 你可以用通用文本编辑器：notepad++，sublime，也可以用专用的MarkPad,Mou。 祝你开心每一天！！！(^▽^)]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
