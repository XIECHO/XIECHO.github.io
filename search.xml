<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java核心技术卷一（1~5）]]></title>
    <url>%2F2018%2F05%2F15%2F515%2F</url>
    <content type="text"><![CDATA[final 在Java中，利用关键字final指示常量，常量名使用全大写。 可以将实例域定义为final。构建对象时必须初始化这样的域并且在后面的操作中，不能在对它进行修改。 final类和方法：阻止人们利用某个类定义子类，子类不能覆盖这个方法 static 静态域 静态常量 ： public static final double PI = 3.14159… 静态方法 整数被0除将会产生一个异常，而浮点数被0除将会得到无穷大或NAN结果。 一定不要使用 == 运算符检测两个字符串是否相等！这个运算符只能够确定两个字符串是否放置在同一个位置上。 检查一个字符串既不是null也不为空串。首先要检查str不为null。1if(str != null &amp;&amp; str.length() != 0) 用比较短的字符串构建字符串，采用字符串连接的方式达到此目的效率比较低，使用StringBuilder类比较高效。 Scanner与Console: 为了安全起见，返回的密码存放在一维字符 数组中，而不是字符串中。 可以使用静态的String.format 方法创建一个格式化的字符串，而不打印输出：1String message = String.format("Hello, %s. Next year, you'll be %d", name, age); 如果在case分支语句的末尾没有break语句，那么就会接着执行下一个case分支语句。 创建一个数字数组时， 所有元素都初始化为0。 boolean数组的元素会初始化为false。 对象数组的元素则初始化为一个特殊值null。 可以使用foreach循环的有 ： 数组或者一个实现了Iterable接口的类对象 如果希望将一个数组的所有值拷贝到一个新的数组中去，可以使用1int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers,luckyNumbers.length); Arrays.sort(type[] a) : 使用了优化的快速排序 Arrays.toString(type[] a) : 打印一维数组 Arrays.deepToString(type[][] a) : 打印二维（多维）数组 第四章一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。 java对象都是在堆中构造的。 关键字this表示隐式参数 在些实例变量的get方法（访问器方法）时，注意不要返回可变对象，如果需要返回一个可变对象的引用，应该首先对它进行克隆（clone）。 1234567class Employee&#123; ... public boolean equals(Employee other)&#123; return name.equals(other.name); &#125;&#125; 这个方法访问harry的私有域，它还访问了boss的私有域。方法可以访问所属类的私有特性，而不仅限于访问隐式参数的私有特性。 Java程序设计语言总是采用按值调用。 不能有两个名字相同、参数类型也相同却返回不同类型值的方法。 必须明确地初始化方法中地局部变量。但是，如果没有初始化类中地域，将会被自动初始化为默认值(0，false或null) 由于初始化数据域有多种途径，所以列出构造过程的所有路径可能相当混乱。下面是调用构造器的具体处理步骤：1）所有数据域被初始化为默认值（0，false或null）。2）按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块。3）如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。4）执行这个构造体的主体。 第五章super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。 在运行时能够自动地调用哪个方法的现象称为动态绑定。 int intValue() : 以int的形式返回Integer对象的值 static int parseInt(String s, int radix) : 返回字符串s表示的整型数值 static Integer valueOf(String s) : 返回s表示的整型数字进行初始化后的一个新的Integer对象。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[多线程归纳]]></title>
    <url>%2F2018%2F05%2F12%2F512%2F</url>
    <content type="text"><![CDATA[线程的创建 继承Thread类 1234567class MyThread extends Thread&#123; public void run() &#123; while(true) &#123; System.out.println("MyThread类的run()方法在运行"); &#125; &#125;&#125; 实现Runnable接口 1234567class MaxPriority implements Runnable&#123; public void run() &#123; for(int i=0; i&lt;10; i++) &#123; System.out.println(Thread.currentThread().getName()+"正在输出：" + i); &#125; &#125;&#125; 12345678910new Thread(new Runnable() &#123; @Override public void run() &#123; Random random = new Random(); for (int i = 0; i &lt; 10; ++i) &#123; sleep(random.nextInt(1000)); System.out.println(String.format("T%d : %d", tid, i)); &#125; &#125;&#125;).start(); Thread中的方法 start() : 启动 setDaemon(boolean bool) ： 设置后台线程 getName() : 获得当前线程名字 setPriority(int value) : 设置线程优先级 Thread.sleep(int value) : 休眠 Thread.currentThread() : 获取当前线程 Thread.yield() : 线程让步 join() : 线程插队 同步同步代码块123synchronized(lock)&#123; 操作共享资源代码块&#125; 其中lock是一个锁对象，锁对象可以是任意类型的对象，但多个线程共享的锁对象必须是唯一的 同步方法1synchronized 返回值类型 方法名([参数1,....])&#123;&#125; 同步代码块的锁是自己定义的任意类型的对象，同步方法的锁当前调用该方法的对象，静态方法的锁是该方法所在类的class对象。同步解决了安全问题，但降低了效率。 死锁同步队列 BlockingQueue是一个接口 抛出异常 特殊值 阻塞 超时 插入 add(e) offer(e) put(e) offer(e, time, unit) 移除 remove() poll() take() poll(time, unit) 检查 element() peek() 不可用 不可用 多线程通信 void wait() : 当前线程放弃同步锁并进入等待，直到其他线程进入此同步锁，并调用notify()方法，或notifyAll()方法唤醒该线程为止 void notify() : 唤醒此同步锁上等待的第一个调用wait()方法的线程 void notifyAll() : 唤醒此同步锁上调用wait()方法的所有线程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class demo &#123; public static void main(String[] args) &#123; Storage st = new Storage(); Input input = new Input(st); Output output = new Output(st); new Thread(input).start(); new Thread(output).start(); &#125;&#125;class Storage&#123; private int[] cells = new int[10]; private int inPos, outPos; private int count; public synchronized void put(int num) &#123; try &#123; while(count == cells.length) &#123; this.wait(); &#125; cells[inPos] = num; System.out.println("在cells[" + inPos +"]中放入数据---" + cells[inPos]); inPos++; if(inPos == cells.length) inPos = 0; count++; this.notify(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; public synchronized void get() &#123; try &#123; while(count == 0) &#123; this.wait(); &#125; int data = cells[outPos]; System.out.println("从celss[" + outPos + "]中取出数据" + data); outPos++; if(outPos == cells.length) outPos = 0; &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 这个和操作系统里的pv操作是一样的。 ThreadLocal 线程局部变量。即使是一个static成员，每个线程访问的变量是不同的。 常见于web中存储当前用户到一个静态工具类中，在线程的任何地方都可以访问到当前线程的用户。 参考HostHolder.java里的users Executor 提供一个运行任务的框架。 将任务和如何运行任务解耦。 常用于提供线程池或定时任务服务 123456789ExecutorService service = Executors.newFixedThreadPool(2);service.submit(new Runnable() &#123; public void run() &#123; for (int i = 0; i &lt; 10; ++i) &#123; Thread.sleep(1000); System.out.println("Execute %d" + i); &#125; &#125;&#125;); Future 返回异步结果 阻塞等待返回结果 timeout 获取线程中的Exception123456789101112131415161718public static void testFuture() &#123; ExecutorService service = Executors.newSingleThreadExecutor(); Future&lt;Integer&gt; future = service.submit(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; sleep(1000); // throw new IllegalArgumentException("一个异常"); return 1; &#125; &#125;); service.shutdown(); try &#123; System.out.println(future.get()); // System.out.println(future.get(100, TimeUnit.MILLISECONDS)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[String归纳]]></title>
    <url>%2F2018%2F05%2F10%2F510%2F</url>
    <content type="text"><![CDATA[String类中有一个 char value[] 字符数组，很多操作都是对数组操作 String类的常用方法获取功能 int length() : 获取字符串的长度，也就是获取字符串中包含的字符数 数组中的表示数组的长度是属性length，由于是属性，后面没有() 字符串中的表示字符串的长度是方法length()，由于是方法，后面有() char charAt(int index) : 根据位置获取该字符串指定位置中的某个字 如果访问到字符串中不存在的角标，会抛出运行时异常—字符串越界异常 java.lang.StringIndexOutOfBoundsException int indexOf(int ch) : 根据字符获取该字符中第一次出现的位置 int indexOf(int ch, int fromIndexi) int indexOf(String str) … String subString(int beginIndex) : 获取从指定位置开始一直到结尾的字串 判断功能 boolean contains(CharSequence s) : 判断字符串是否为空 contains的底层为 indexOf方法 CharSequence是一个接口,实现子类有String、StringBuilder和StringBuffer123public boolean contains(CharSequence s) &#123; return indexOf(s.toString()) &gt; -1;&#125; boolean isEmpty() 123public boolean isEmpty() &#123; return value.length == 0;&#125; boolean startsWith(String str) : 判断字符串是否以指定内容开头 boolean endsWith(String str) boolean equals(String str) : 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; 替换功能 String replace(char oldChar, char newChar) 1234public String replace(CharSequence target, CharSequence replacement) &#123; return Pattern.compile(target.toString(), Pattern.LITERAL).matcher( this).replaceAll(Matcher.quoteReplacement(replacement.toString()));&#125; 用正则表达式解析，replace返回的是新的字符串引用，如果没有替换的内容，则返回原来的字符串引用 String replace (CharSequence target, CharSequence replacement) 转换功能 static String valueOf():可以操作字符数组，也可以是基本类型 char[] toCharArray(): 字符串==&gt;字符数组 其他功能 int compareTo(String anotherString) : 实际上是实现CompareTo接口的方法compareTo() String[] split(String regex) : 参数可以是正则表达式，也可以是普通字符串]]></content>
      <categories>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[最近的我]]></title>
    <url>%2F2018%2F05%2F09%2F509_1%2F</url>
    <content type="text"><![CDATA[到6号，把剑指offer的题目过了一遍，66个题目，尽管没有每个都会，但第一次我发现我可以一次写出青蛙跳楼梯的题目，第一次可以写出难一点的递归，链表等等，有些惊喜，又有些失落，这些我以前就该会的。。。。 7号开始整理排序算法，把快排，堆排，希尔排序，归并排序这些都自己手写了一遍，尽管我以前也知道这些思想，可从来没动过手自己写一遍~ 尝试写冒泡排序的时候，真的冏，好难啊，写快排的时候，各种边界问题，但静下心，回想算法的思想后，在纸上写下注意点后，开始写，就轻松多了，从没想过能手写出来这些。。 今天，整理查找，第一次知道hashmap为什么不能处理有序，hashmap底层是数组+链表，以前这些只是知道我们可以通过hashmap可以存取东西，从没想过它是怎么存的额，为什么它会快，也从来没想过数据库为什么会有些适合查询，不适合插入。。。 我不知道，怎么去形容此刻的自己，真的菜。。。 其实，是不是每个厉害的人，都能随手写出这些东西的。。。 单身快两年，有些荷尔蒙冲动了，但不知道怎么办了。,,ԾㅂԾ,,]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[查找]]></title>
    <url>%2F2018%2F05%2F09%2F509%2F</url>
    <content type="text"><![CDATA[符号表符号表最主要的目的就是将一个键和一个值联系起来。 无序链表中的顺序查找（顺序查找）符号表中使用的数据结构的一个简单选择时链表，每个节点存储一个键值对。 #]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2018%2F05%2F07%2F507%2F</url>
    <content type="text"><![CDATA[传统排序排序对象应该是一切可以排序的对象，实现了Comparable接口的对象，文中主要用int(当然可以用泛型) 简单选择排序思路选择数组中最小的一个，与第一个元素交换，再选择数组中最小一个，与第二个交换，如此往复。需要 N(N-1)/2 比较和 N 次交换 代码123456789101112131415public class Sort&#123; public static void selectedSort(int[] array)&#123; for(int i = 0; i&lt;array.length; i++)&#123; int min = i; for(int j = i+1; j&lt;array.length; j++)&#123; if(array[j] &lt; array[min])&#123; min = j; &#125; &#125; int temp = array[i]; array[i] = array[min]; array[min] = temp; &#125; &#125;&#125; 插入排序思路将新数据插入到排好序的数组，类似于整理纸牌 代码1234567891011public class Sort&#123; public static void insertSort(int[] array) &#123; for(int i = 1; i&lt;array.length; i++) &#123; int current = array[i]; for(int j = i-1; j&gt;=0 &amp;&amp; array[j] &gt; current;j--) &#123; array[j+1]=array[j]; array[j] = current; &#125; &#125; &#125;&#125; More插入排序对部分有序的数组特别有效 数组中每个元素距离它的最终位置都不远 一个有序的大数组接一个小数组 数组中只有几个元素的位置不正确 希尔排序思路要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。你将会看到，归并排序最吸引人地性质是它能够保证将任意长度为N地数组排序所需时间和NlogN成正比；缺点是它需要额外空间和N成正比。 代码12345678910111213141516public class Sort&#123; public static void shellSort(int[] array) &#123; int h = 1; while(h &lt; array.length/3) h = h*3+1; while(h &gt;= 1) &#123; for(int i = h; i &lt; array.length; i++) &#123; int current = array[i]; for(int j = i-h; j &gt;=0 &amp;&amp; array[j] &gt; current; j = j-h) &#123; array[j+h] = array[j]; array[j] = current; &#125; &#125; h = h/3; &#125; &#125;&#125; More希尔排序为了加快速度简单地改进了插入排序，交换不相邻地元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。 归并排序要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。你将会看到，归并排序最吸引人地性质是它能够保证将任意长度为N的数组排序所需时间和NlogN成正比，它的主要缺点则是它所需的额外空间和N成正比。 自顶向下的归并排序代码123456789101112131415161718192021222324252627282930313233343536public class Sort&#123; public static void mergeUB(int[] array) &#123; mergeUB(array, 0, array.length - 1); &#125; public static void mergeUB(int[] array, int start, int end) &#123; if(end &lt;= start) return; int mid = start + (end - start)/2; mergeUB(array, start, mid); mergeUB(array, mid+1, end); merge(array, start, mid, end); &#125; public static void merge(int[] array, int start, int mid, int end) &#123; int left = start; int right = mid + 1; int aux[] = new int[array.length]; for (int i = start; i &lt; array.length; i++) &#123; aux[i] = array[i]; &#125; for (int i = start; i &lt; aux.length; i++) &#123; if (left &gt; mid) &#123; array[i] = aux[right++]; &#125; else if (right &gt; end) &#123; array[i] = aux[left++]; &#125; else if (aux[left] &gt; aux[right]) &#123; array[i] = aux[right++]; &#125; else &#123; array[i] = aux[left++]; &#125; &#125; &#125;&#125; 自底向上的归并排序代码123456789101112131415161718192021222324252627282930public class Sort&#123; public static void mergeBU(int[] array) &#123; for(int i=1; i&lt;array.length; i=i+i) &#123; for(int j = 0; j &lt; array.length - i ; j = j+i+i) &#123; merge(array, j, j+i-1, Math.min(j+i+i-1, array.length-1)); &#125; &#125; &#125; public static void merge(int[] array, int start, int mid, int end) &#123; int left = start; int right = mid + 1; int aux[] = new int[array.length]; for(int i=start; i&lt;array.length; i++) &#123; aux[i] = array[i]; &#125; for(int i=start; i&lt;aux.length; i++) &#123; if(left &gt; mid) &#123; array[i] = aux[right++]; &#125;else if(right &gt; end) &#123; array[i] = aux[left++]; &#125;else if(aux[left] &gt; aux[right]) &#123; array[i] = aux[right++]; &#125;else &#123; array[i] = aux[left++]; &#125; &#125; &#125;&#125; 注意点merge() 函数中注意循环的开始是 i = start。 快速排序思路要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。你将会看到，归并排序最吸引人地性质是它能够保证将任意长度为N地数组排序所需时间和NlogN成正比；缺点是它需要额外空间和N成正比。 代码123456789101112131415161718192021222324252627282930public class Sort&#123; public static void quickSort(int[] array) &#123; quickSort(array, 0, array.length - 1); &#125; public static void quickSort(int[] array, int start, int end) &#123; if(end &lt;= start) return; int j = partition(array, start, end); quickSort(array, start, j-1); quickSort(array, j+1, end); &#125; private static int partition(int[] array, int start, int end) &#123; int i = start, j = end+1; int v = array[start]; while(true) &#123; while(array[++i] &lt; v) if(i == end) break; while(v &lt; array[--j]) if(j == start) break; if(i &gt;= j) break; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; int temp = array[start]; array[start] = array[j]; array[j] = temp; return j; &#125;&#125; More堆排序思路代码1234567891011121314151617181920212223242526272829303132333435public class Sort&#123; public static void MinHeap_Sort(int array[], int n) &#123; int temp = 0; MakeMinHeap(array, n); for(int i = n-1; i&gt;0; i--) &#123; temp = array[0]; array[0] = array[i]; array[i] = temp; MinHeapFixdown(array, 0, i); &#125; &#125; private static void MinHeapFixdown(int[] array, int i, int n) &#123; int j = 2*i + 1; int temp = 0; while(j&lt;n) &#123; if(j+1 &lt; n &amp;&amp; array[j+1] &lt; array[j]) &#123; j++; &#125; if(array[i] &lt;= array[j]) break; temp = array[i]; array[i] = array[j]; array[j] = temp; i = j; j = 2*i + 1; &#125; &#125; private static void MakeMinHeap(int[] array, int n) &#123; for(int i = (n-1)/2; i&gt;=0; i--) &#123; MinHeapFixdown(array,i,n); &#125; &#125;&#125; Moreothersstack peek():查看堆栈顶部的对象，但不从堆栈中移除它。 pop():移除堆栈顶部的对象，并作为此函数的值返回该对象 push():把项压入堆栈顶部queue peek():获取但不移除此队列的头；如果此队列为空，则返回null。 poll():获取并移除此队列的头，如果此队列为空，则返回null remove():获取并移除此队列的头 offer():将指定的元素插入此队列(如果立即可行且不会违反容量限制)，当使用有容量限制的队列时，此方法通常要优于add(E)，后者可能无法插入元素，而只是抛出一个异常。 element():获取，但是不移除此队列的头。 add():将指定的元素插入此队列]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_506]]></title>
    <url>%2F2018%2F05%2F06%2F506%2F</url>
    <content type="text"><![CDATA[题目描述 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 代码123456789101112131415161718192021222324public class Solution &#123; public int movingCount(int threshold, int rows, int cols) &#123; boolean[][] visited = new boolean[rows][cols]; return count(threshold, rows, cols, 0, 0, visited); &#125; public static int count(int threshold, int rows, int cols, int r, int c, boolean[][] visited)&#123; if(r &lt; 0 || r &gt;= rows || c &lt; 0 || c &gt;= cols || visited[r][c] == true || sum(c) + sum(r) &gt; threshold) return 0; visited[r][c] = true; return count(threshold, rows, cols, r+1, c, visited) + count(threshold, rows, cols, r-1, c, visited) + count(threshold, rows, cols, r, c+1, visited) + count(threshold, rows, cols, r, c-1, visited) + 1; &#125; public static int sum(int value)&#123; int sumValue = 0; while(value != 0)&#123; sumValue = sumValue + value % 10; value = value / 10; &#125; return sumValue; &#125;&#125; 题目描述 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 代码12345678910111213141516171819202122232425262728293031/*public class Solution &#123; public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; boolean[] visited = new boolean[matrix.length]; int k = 0; for(int i = 0; i&lt;rows; i++)&#123; for(int j = 0; j&lt;cols; j++)&#123; if(find(matrix, rows, cols, str, i, j, 0, visited)) return true; &#125; &#125; return false; &#125; public boolean find(char[] matrix, int rows, int cols, char[] str, int i, int j,int k, boolean[] visited)&#123; int loc = i * cols + j ; if(i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols || visited[loc] || str[k] != matrix[loc]) return false; if(k == str.length - 1) return true; visited[loc] = true; k++; if(find(matrix, rows, cols, str, i+1, j, k, visited) || find(matrix, rows, cols, str, i, j+1, k, visited) || find(matrix, rows, cols, str, i-1, j, k, visited)|| find(matrix, rows, cols, str, i, j-1, k, visited))&#123; return true; &#125; visited[loc] = false; return false; &#125;&#125; 思路题目描述 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 坑引用的问题 代码123456789101112131415161718192021222324252627import java.util.*;public class Solution &#123; public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size) &#123; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); ArrayList&lt;Integer&gt; max = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; num.length; i++)&#123; list.add(num[i]); if(list.size() == size)&#123; max.add(max(list)); list.removeFirst(); &#125; &#125; return max; &#125; public static int max(LinkedList&lt;Integer&gt; list)&#123; LinkedList&lt;Integer&gt; list1 = new LinkedList&lt;&gt;(); for(Integer i : list) &#123; list1.add(i); &#125; Collections.sort(list1); return list1.getLast(); &#125;&#125; 题目描述 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 代码123456789101112public class Solution &#123; public int NumberOf1(int n) &#123; String ns = Integer.toBinaryString(n); char[] nsc = ns.toCharArray(); int count = 0; for(char temp : nsc)&#123; if(temp == '1') count++; &#125; return count; &#125;&#125; 题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 代码1234567891011121314151617181920212223242526272829303132public class Solution &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; for(int i = 0 ; i &lt; array.length; i++)&#123; for(int j = 0 ; j &lt; array.length -1 -i; j++)&#123; if(array[j] &lt; array[j+1])&#123; int temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; &#125; &#125; &#125; int count =0; int temp = array[0]; for(int i = 0; i&lt;array.length; i++)&#123; if(array[i] == temp)&#123; ++count; if(count &gt; array.length/2)&#123; return temp; &#125; &#125;else&#123; if(count &gt; array.length/2)&#123; return temp; &#125;else&#123; temp = array[i]; count = 1; &#125; &#125; &#125; return 0; &#125;&#125; 题目描述 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 代码123456789101112131415161718192021222324import java.util.*;public class Solution &#123; public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; for(int i = 0; i&lt;input.length; i++)&#123; for(int j = 0; j &lt; input.length-1-i; j++)&#123; if(input[j] &gt; input[j+1])&#123; int temp = input[j]; input[j] = input[j+1]; input[j+1] = temp; &#125; &#125; &#125; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(k &gt; input.length)&#123; return list; &#125; for(int i = 0; i&lt;k;i++)&#123; list.add(input[i]); &#125; return list; &#125;&#125; 题目描述 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 代码123456789101112131415161718192021222324import java.util.Arrays;import java.util.Comparator;public class Solution &#123; public String PrintMinNumber(int [] numbers) &#123; String[] snum = new String[numbers.length]; for (int i = 0; i &lt; numbers.length; i++) &#123; snum[i] = String.valueOf(numbers[i]); &#125; Arrays.sort(snum, new Comparator&lt;String&gt;() &#123; public int compare(String s1, String s2) &#123; String c1 = s1 + s2; String c2 = s2 + s1; return c1.compareTo(c2); &#125; &#125;); String last = ""; for (String temp : snum) &#123; last = last + temp; &#125; return last; &#125;&#125; 题目描述 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。 代码1234567891011121314public class Solution &#123; public int NumberOf1Between1AndN_Solution(int n) &#123; String temp = ""; int count = 0; for(int i = 1; i &lt;= n; i++)&#123; temp = String.valueOf(i); while(temp.contains("1"))&#123; count++; temp = temp.substring(temp.indexOf('1')+1); &#125; &#125; return count; &#125;&#125; 题目描述 把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 代码123456789101112131415161718192021222324import java.util.*;public class Solution &#123; public int GetUglyNumber_Solution(int index) &#123; if (index &lt; 7) return index; int[] ret = new int[index]; ret[0] = 1; int t2 = 0, t3 = 0, t5 = 0; for (int i = 1; i &lt; index; i++) &#123; ret[i] = min(min(ret[t2] * 2, ret[t3] * 3), ret[t5] * 5); if (ret[i] == ret[t2] * 2) t2++; if (ret[i] == ret[t3] * 3) t3++; if (ret[i] == ret[t5] * 5) t5++; &#125; return ret[index - 1]; &#125; public static int min(int a,int b) &#123; return a&lt;b ? a : b; &#125;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_505]]></title>
    <url>%2F2018%2F05%2F05%2F505%2F</url>
    <content type="text"><![CDATA[题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 代码12345678910111213public class Solution &#123; public int minNumberInRotateArray(int [] array) &#123; if(array.length == 0)&#123; return 0; &#125; for(int i = 0; i &lt; array.length - 1; i++)&#123; if(array[i] &gt; array[i + 1])&#123; return array[i + 1]; &#125; &#125; return array[0]; &#125;&#125; 题目描述 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 代码1234567891011121314151617181920212223242526/*import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; if (stack2.isEmpty() &amp;&amp; stack1.isEmpty()) &#123; return 0; &#125; else &#123; if (stack2.isEmpty()) &#123; while (!stack1.isEmpty()) &#123; stack2.push(stack1.pop()); &#125; return stack2.pop(); &#125; else &#123; return stack2.pop(); &#125; &#125; &#125;&#125; 思路题目描述 定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。 代码123456789101112131415161718192021222324252627282930313233343536373839import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; data = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; min = new Stack&lt;Integer&gt;(); Integer temp = null; public void push(int node) &#123; if(temp != null)&#123; if(temp &gt;= node)&#123; temp = node; min.push(node); &#125; data.push(node); &#125;else&#123; temp = node; min.push(node); data.push(node); &#125; &#125; public void pop() &#123; int num = data.pop(); int num2 = min.pop(); if(num != num2)&#123; min.push(num2); &#125; &#125; public int top() &#123; return data.peek(); &#125; public int min() &#123; int num = min.pop(); min.push(num); return num; &#125;&#125; 题目描述 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 代码123456789101112public class Solution &#123; public int NumberOf1(int n) &#123; String ns = Integer.toBinaryString(n); char[] nsc = ns.toCharArray(); int count = 0; for(char temp : nsc)&#123; if(temp == '1') count++; &#125; return count; &#125;&#125; 题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 代码1234567891011121314151617181920212223242526272829303132public class Solution &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; for(int i = 0 ; i &lt; array.length; i++)&#123; for(int j = 0 ; j &lt; array.length -1 -i; j++)&#123; if(array[j] &lt; array[j+1])&#123; int temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; &#125; &#125; &#125; int count =0; int temp = array[0]; for(int i = 0; i&lt;array.length; i++)&#123; if(array[i] == temp)&#123; ++count; if(count &gt; array.length/2)&#123; return temp; &#125; &#125;else&#123; if(count &gt; array.length/2)&#123; return temp; &#125;else&#123; temp = array[i]; count = 1; &#125; &#125; &#125; return 0; &#125;&#125; 题目描述 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 代码123456789101112131415161718192021222324import java.util.*;public class Solution &#123; public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; for(int i = 0; i&lt;input.length; i++)&#123; for(int j = 0; j &lt; input.length-1-i; j++)&#123; if(input[j] &gt; input[j+1])&#123; int temp = input[j]; input[j] = input[j+1]; input[j+1] = temp; &#125; &#125; &#125; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(k &gt; input.length)&#123; return list; &#125; for(int i = 0; i&lt;k;i++)&#123; list.add(input[i]); &#125; return list; &#125;&#125; 题目描述 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 代码123456789101112131415161718192021222324import java.util.Arrays;import java.util.Comparator;public class Solution &#123; public String PrintMinNumber(int [] numbers) &#123; String[] snum = new String[numbers.length]; for (int i = 0; i &lt; numbers.length; i++) &#123; snum[i] = String.valueOf(numbers[i]); &#125; Arrays.sort(snum, new Comparator&lt;String&gt;() &#123; public int compare(String s1, String s2) &#123; String c1 = s1 + s2; String c2 = s2 + s1; return c1.compareTo(c2); &#125; &#125;); String last = ""; for (String temp : snum) &#123; last = last + temp; &#125; return last; &#125;&#125; 题目描述 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。 代码1234567891011121314public class Solution &#123; public int NumberOf1Between1AndN_Solution(int n) &#123; String temp = ""; int count = 0; for(int i = 1; i &lt;= n; i++)&#123; temp = String.valueOf(i); while(temp.contains("1"))&#123; count++; temp = temp.substring(temp.indexOf('1')+1); &#125; &#125; return count; &#125;&#125; 题目描述 把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 代码123456789101112131415161718192021222324import java.util.*;public class Solution &#123; public int GetUglyNumber_Solution(int index) &#123; if (index &lt; 7) return index; int[] ret = new int[index]; ret[0] = 1; int t2 = 0, t3 = 0, t5 = 0; for (int i = 1; i &lt; index; i++) &#123; ret[i] = min(min(ret[t2] * 2, ret[t3] * 3), ret[t5] * 5); if (ret[i] == ret[t2] * 2) t2++; if (ret[i] == ret[t3] * 3) t3++; if (ret[i] == ret[t5] * 5) t5++; &#125; return ret[index - 1]; &#125; public static int min(int a,int b) &#123; return a&lt;b ? a : b; &#125;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_504]]></title>
    <url>%2F2018%2F05%2F04%2F504%2F</url>
    <content type="text"><![CDATA[题目描述 输入一个链表，输出该链表中倒数第k个结点。 代码123456789101112131415161718192021222324252627/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; ListNode first = head; for(int i = 0; i&lt;k; i++)&#123; if(head == null)&#123; return null; &#125; head = head.next; &#125; while(head != null)&#123; head = head.next; first = first.next; &#125; return first; &#125;&#125; 题目描述 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 代码12345678910111213141516171819202122232425262728293031323334/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; ListNode head = new ListNode(0); ListNode list = head; while(list1 != null &amp;&amp; list2 != null)&#123; if(list1.val &lt;= list2.val)&#123; list.next = list1; list = list.next; list1 = list1.next; &#125;else&#123; list.next = list2; list = list.next; list2 = list2.next; &#125; &#125; if(list1 != null)&#123; list.next = list1; &#125;else&#123; list.next = list2; &#125; return head.next; &#125;&#125; 思路题目描述 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 代码123456789101112131415161718192021import java.util.ArrayList;import java.util.List;public class Solution &#123; public void reOrderArray(int [] array) &#123; List&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); List&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;(); for(int i=0;i&lt;array.length;i++)&#123; if(array[i]%2==0)&#123; list2.add(array[i]); &#125;else&#123; list1.add(array[i]); &#125; &#125; for(int i=0;i&lt;list1.size();i++)&#123; array[i] = list1.get(i); &#125; for(int i=list1.size(),j=0;i&lt;list1.size()+list2.size();i++,j++)&#123; array[i] = list2.get(j); &#125; &#125;&#125; 题目描述 输入一个链表，反转链表后，输出链表的所有元素。 代码12345678910111213141516171819202122/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; ListNode newHead = null; ListNode first = null; while(head != null)&#123; newHead = head.next; head.next = first; first = head; head = newHead; &#125; return first; &#125;&#125; 题目描述 统计一个数字在排序数组中出现的次数。 代码1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; public int GetNumberOfK(int[] array, int k) &#123; int length = array.length; int start = 0; int end = length - 1; int mid = (end + start) / 2; int temp = -1; int count = 0; while (end &gt;= start) &#123; if (array[mid] == k) &#123; temp = mid; break; &#125; else if (array[mid] &gt; k) end = mid - 1; else start = mid + 1; mid = (end + start) / 2; &#125; if (temp == -1) &#123; return 0; &#125; else &#123; for (int i = temp; i &gt;= 0; i--) &#123; if (array[i] == k) &#123; count++; &#125; else &#123; break; &#125; &#125; for (int j = temp + 1; j &lt; length; j++) &#123; if (array[j] == k) &#123; count++; &#125; else &#123; break; &#125; &#125; return count; &#125; &#125;&#125; 题目描述 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 代码1234567891011121314151617public class Solution &#123; public String LeftRotateString(String str,int n) &#123; char[] st = str.toCharArray(); if(str.equals("")) return str; if(st.length &lt; n) n = n%st.length; String s = ""; for(int i = n; i&lt;st.length; i++)&#123; s = s + st[i]; &#125; for(int i = 0; i&lt;n; i++)&#123; s = s + st[i]; &#125; return s; &#125;&#125; 题目描述 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 代码1234567891011121314151617public class Solution &#123; public boolean IsPopOrder(int[] pushA, int[] popA) &#123; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for (int i = 0, j = 0; i &lt; pushA.length; i++) &#123; list.add(pushA[i]); while (j &lt; popA.length &amp;&amp; list.getLast() == popA[j]) &#123; list.removeLast(); j++; &#125; &#125; if (list.isEmpty()) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_503]]></title>
    <url>%2F2018%2F05%2F03%2F503%2F</url>
    <content type="text"><![CDATA[题目描述 将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0 ascii码表数字0-9：48-57字母A-Z：65-90字母a-z：97-122 字符串中的”==” 和 equals（）的的区别我会很习惯的认为两个字符串用”==”，这个是比较地址，不是比较内容，内容用equals（） 代码12345678910111213141516171819202122public class Solution&#123; public int StrToInt(String str) &#123; if(str.equals("")) return 0; char[] st = str.toCharArray(); int fuhao = 0; if(st[0] == '-')&#123; fuhao = 1; &#125; int sum = 0; for(int i = fuhao; i &lt; st.length; i++)&#123; if(st[i] == '+') continue; if(st[i] &lt; 48 || st[i] &gt; 58) return 0; sum = 10 * sum + st[i] - 48; &#125; return fuhao == 0 ? sum : sum * -1; &#125;&#125; 题目描述 输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 代码1234567891011121314151617181920import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); int start = 0; int end = array.length - 1; while(start &lt; end)&#123; if(array[start] + array[end] == sum)&#123; list.add(array[start]); list.add(array[end]); return list; &#125;else if(array[start] + array[end] &gt; sum)&#123; end--; &#125;else&#123; start++; &#125; &#125; return list; &#125;&#125; 思路题目描述 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 代码1234567891011121314151617public class Solution &#123; public String ReverseSentence(String str) &#123; String[] sp = str.split(" "); String temp = ""; if(str.trim().equals(""))&#123; return str; &#125; for(int i = sp.length -1; i &gt;= 0;i--)&#123; if(i == 0)&#123; temp = temp + sp[i]; break; &#125; temp = temp + sp[i]+" "; &#125; return temp; &#125;&#125; 题目描述 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 代码123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.*;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public int TreeDepth(TreeNode root) &#123; if(root == null)&#123; return 0; &#125; int count = 0; LinkedList&lt;TreeNode&gt; list = new LinkedList&lt;&gt;(); list.add(root); int start = 0; int end = 1; while(!list.isEmpty())&#123; root = list.remove(); start ++; if(root.left != null)&#123; list.add(root.left); &#125; if(root.right != null)&#123; list.add(root.right); &#125; if(start == end)&#123; count ++; start = 0; end = list.size(); &#125; &#125; return count; &#125;&#125; 题目描述 统计一个数字在排序数组中出现的次数。 代码1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; public int GetNumberOfK(int[] array, int k) &#123; int length = array.length; int start = 0; int end = length - 1; int mid = (end + start) / 2; int temp = -1; int count = 0; while (end &gt;= start) &#123; if (array[mid] == k) &#123; temp = mid; break; &#125; else if (array[mid] &gt; k) end = mid - 1; else start = mid + 1; mid = (end + start) / 2; &#125; if (temp == -1) &#123; return 0; &#125; else &#123; for (int i = temp; i &gt;= 0; i--) &#123; if (array[i] == k) &#123; count++; &#125; else &#123; break; &#125; &#125; for (int j = temp + 1; j &lt; length; j++) &#123; if (array[j] == k) &#123; count++; &#125; else &#123; break; &#125; &#125; return count; &#125; &#125;&#125; 题目描述 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 代码1234567891011121314151617public class Solution &#123; public String LeftRotateString(String str,int n) &#123; char[] st = str.toCharArray(); if(str.equals("")) return str; if(st.length &lt; n) n = n%st.length; String s = ""; for(int i = n; i&lt;st.length; i++)&#123; s = s + st[i]; &#125; for(int i = 0; i&lt;n; i++)&#123; s = s + st[i]; &#125; return s; &#125;&#125; 题目描述 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 代码1234567891011121314151617public class Solution &#123; public boolean IsPopOrder(int[] pushA, int[] popA) &#123; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for (int i = 0, j = 0; i &lt; pushA.length; i++) &#123; list.add(pushA[i]); while (j &lt; popA.length &amp;&amp; list.getLast() == popA[j]) &#123; list.removeLast(); j++; &#125; &#125; if (list.isEmpty()) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_502]]></title>
    <url>%2F2018%2F05%2F02%2F502%2F</url>
    <content type="text"><![CDATA[题目描述 HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1) 代码1234567891011121314151617181920212223242526public class Solution &#123; public int FindGreatestSumOfSubArray(int[] array) &#123; int length = array.length; int[] temp = new int[length + 1]; if(length &gt; 0)&#123; temp[0] = array[0]; temp[length] = array[0]; for(int i = 1; i &lt; length; i++)&#123; if(temp[i - 1] &gt; 0)&#123; temp[i] = temp[i - 1] + array[i]; if(temp[length] &lt; temp[i])&#123; temp[length] = temp[i]; &#125; &#125;else&#123; temp[i] = array[i]; if(temp[length] &lt; temp[i])&#123; temp[length] = temp[i]; &#125; &#125; &#125; return temp[length]; &#125; else&#123; return 0; &#125; &#125;&#125; 思路用一个Boolean数组判断数字有没有重复过。 坑1 Boolean数组默认初始值是false 题目描述 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法 代码```javaimport java.util.ArrayList;public class Solution { public int[] multiply(int[] A) { int aLength = A.length; int[] value = new int[aLength]; for(int i = 0 ; i]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[仙居之旅]]></title>
    <url>%2F2018%2F05%2F01%2F501%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[字符串]]></title>
    <url>%2F2018%2F04%2F28%2F428_2%2F</url>
    <content type="text"><![CDATA[替换空格题目描述 请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 代码123456789101112131415public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; String strT = str.toString(); String temp = ""; char[] ch = strT.toCharArray(); for(int i = 0; i &lt; ch.length; i++)&#123; if(ch[i] == ' ')&#123; temp = temp + "%20"; &#125;else&#123; temp = temp + ch[i]; &#125; &#125; return temp; &#125;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归]]></title>
    <url>%2F2018%2F04%2F28%2F428_1%2F</url>
    <content type="text"><![CDATA[斐波那契数列题目描述 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39 代码1234567891011public class Solution &#123; public int Fibonacci(int n) &#123; if(n == 0 )&#123; return 0; &#125;else if(n == 1)&#123; return 1; &#125;else &#123; return Fibonacci(n-1)+Fibonacci(n-2); &#125; &#125;&#125; 跳台阶题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 代码1234567891011public class Solution &#123; public int JumpFloor(int target) &#123; if(target == 1)&#123; return 1; &#125;else if(target == 2)&#123; return 2; &#125;else&#123; return JumpFloor(target-2)+JumpFloor(target-1); &#125; &#125;&#125; More我记得大三上算法课听过这个题，只不过不会，一直不会，今天写第一次就过了。我擦类。。。。。。。。 变态跳台阶题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 代码123456789public class Solution &#123; public int JumpFloorII(int target) &#123; if( target == 1)&#123; return 1; &#125;else&#123; return 2 * JumpFloorII(target - 1); &#125; &#125;&#125; 思路因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级，跳1级，剩下n-1级，则剩下跳法是f(n-1)，跳2级，剩下n-2级，则剩下跳法是f(n-2)，所以f(n)=f(n-1)+f(n-2)+…+f(1)，因为f(n-1)=f(n-2)+f(n-3)+…+f(1)，所以f(n)=2*f(n-1) 矩形覆盖题目描述 我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 代码12345678910111213public class Solution &#123; public int RectCover(int target) &#123; if(target == 0)&#123; return 0; &#125;else if(target == 1)&#123; return 1; &#125;else if(target == 2)&#123; return 2; &#125;else&#123; return RectCover(target-1)+RectCover(target-2); &#125; &#125;&#125; 思路其实就是Fibonacci序列的等价转换。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维数组中的查找]]></title>
    <url>%2F2018%2F04%2F28%2F428%2F</url>
    <content type="text"><![CDATA[题目描述 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 代码123456789101112131415161718public class Solution &#123; public boolean Find(int target, int [][] array) &#123; int rowLength = array.length; int columnLength = array[0].length; for(int i = rowLength-1, j = 0; i&gt;=0 &amp;&amp; j&lt;columnLength; )&#123; if(array[i][j] &lt; target)&#123; j++; &#125; else if(array[i][j] &gt; target)&#123; i--; &#125; else if(array[i][j] == target)&#123; return true; &#125; &#125; return false; &#125;&#125; 思路选择左下角开始，如果target比当前节点大，则向右，小，向上。 坑1 如何判断一个二位数组为空，一是数组首地址是否为空，二是是否为{}，也就是array.length==0的情况，三是\left\left\right\right，这时array.length=1，但是array[0].length==0。满足任意一个条件就可以返回false了。if(array==null||array.length==0||(array.length==1&amp;&amp;array[0].length==0)) return false;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL入门]]></title>
    <url>%2F2018%2F04%2F27%2F427data%2F</url>
    <content type="text"><![CDATA[数据操作语言（DML） select: 从数据库中获取数据 update： 更新数据库表中的数据 delete： 从数据库中删除数据 insert into : 向数据库中插入数据 数据定义语言（DDL）用于创建和删除表格，也可以定义索引（键），规定表之间的链接，以及施加表间的约束。 create database : 创建新数据库 alter database : 修改数据库 create table ： 创建新表 alter table : 变更（改变）数据库表 drop table : 删除表 create index ： 创建索引（搜索键） drop index : 删除索引 语句select语句 select 列名称 from 表名称 select * from 表名称 select distinct去重复 select distinct 列名称 from 表名称 where子句如需有条件地从表中选取数据，可将where子句添加到select语句。 select 列名称 from 表名称 where 列 运算符 值运算符： =, &lt;&gt;, &gt;, &lt;, &gt;=, &lt;=, between, like AND和OR运算符可在where子语句中把两个或多个条件结合起来。 select * from Persons where FirstName=’Thomas’ and LastName=’Carter’ order by语句order by 语句用于根据指定的列对结果集进行排序。默认升序，降序用desc。 select Company，OrderNumber from Orders order by Company desc select Company, ORderNumber from orders order by Company desc, orderNumber asc desc: descend; asc: ascend insert into语句插入新的行。 insert into 表名称 values(值1， 值2， …) insert into table_name(列1，列2，…) values(值1，值2，…) insert into Persons(lastName, Address) values (‘Wilson’, ‘Chapms-Elysees’) update语句 update 表名称 set 列名称 = ‘新值’ where 列名称 = 某值 delete语句删除表中的行 delect from 表名称 where 列名称 = 值删除所有行 delect from table_name limit语句返回表中头几行 select * from table_name limit number like操作符like操作符用于在where子句中搜索列中的指定模式。 select * from Persons where city like ‘N%’%可用于定义通配符（模式中缺少的字母）， NOT指代不包含 select * from Persons where city not like ‘%lon%’ SQL通配符通配符必须与Like运算符一起使用 通配符 | 描述% | 代替一个或多个字符 | 仅代替一个字符 in select * from table_name where 列 in (值1，值2)]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中重复的数字 && 构建乘积数组]]></title>
    <url>%2F2018%2F04%2F27%2F427%2F</url>
    <content type="text"><![CDATA[题目描述 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 代码1234567891011121314151617181920212223public class Solution &#123; // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation; // Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++ // 这里要特别注意~返回任意重复的一个，赋值duplication[0] // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false public boolean duplicate(int numbers[],int length,int [] duplication) &#123; boolean[] temp = new boolean[length]; for(int i = 0; i&lt;length; i++)&#123; int tempInt = numbers[i]; if(!temp[tempInt])&#123; temp[tempInt] = true; &#125;else&#123; duplication[0] = tempInt; return true; &#125; &#125; return false; &#125;&#125; 思路用一个Boolean数组判断数字有没有重复过。 坑1 Boolean数组默认初始值是false 题目描述 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法 代码```javaimport java.util.ArrayList;public class Solution { public int[] multiply(int[] A) { int aLength = A.length; int[] value = new int[aLength]; for(int i = 0 ; i]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[按之字形顺序打印二叉树]]></title>
    <url>%2F2018%2F04%2F26%2F426_1%2F</url>
    <content type="text"><![CDATA[题目描述 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 代码12345678910public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** 队列LinkedList完成层序遍历，用end记录每层结点数目*/public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123; LinkedList&lt;TreeNode&gt; list = new LinkedList&lt;&gt;(); ArrayList layer = new ArrayList(); ArrayList&lt;ArrayList&lt;Integer&gt;&gt; last = new ArrayList&lt;&gt;(); int start = 0; int end = 1; int count = 1; list.add(pRoot); if(pRoot == null)&#123; return last; &#125; while(! list.isEmpty())&#123; TreeNode t = list.remove(); layer.add(t.val); start++; if(t.left != null)&#123; list.add(t.left); &#125; if(t.right != null)&#123; list.add(t.right); &#125; if(start == end)&#123; start = 0; end = list.size(); if( count % 2 == 0)&#123; Collections.reverse(layer); last.add(layer); &#125;else&#123; last.add(layer); &#125; layer = new ArrayList(); count++; &#125; &#125; return last; &#125;&#125; 思路这个一个层次遍历的应用，中间需要记录每一行的开始（start）和结束（end），来确定一层输出一行。 坑1 我最开始的想法是每一个节点对应一个数字（行号）确定他是在哪一行，等到对应节点的行号与下一个节点不一样的时候，就换行。与上面的代码区别是多了一个ArrayList，记录好多不需要的信息，浪费了。 知识点1 层次遍历 层次遍历，底层就是一个队列。算法思路是： 先将二叉树头节点入队列，然后出队列，访问该节点，如果它有左子树，则将左子树根节点入队，如果它有右子树，则将右子树根节点入队。然后出队列，对出队列节点访问，如此反复，直到队列为空为止。 More代码中是通过LinkedList模拟队列的，Java把队列，栈等数据结构封装的很好，但是最好还是要自己来理解实现一下这些底层。最近有看redis，里面很多操作的底层也是这些基础。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遍历二叉树]]></title>
    <url>%2F2018%2F04%2F26%2F426%2F</url>
    <content type="text"><![CDATA[树定义12345678public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 先序遍历先序遍历递归12345public void preorder(TreeNode root)&#123; System.out.print(root); preorder(root.left); preorder(root.right);&#125; 先序遍历非递归12345678910111213141516public void preorder2(TreeNode root)&#123; LinkedList&lt;TreeNode&gt; list = new LinkedList&lt;&gt;(); while(root != null || !list.isEmpty())&#123; if(root != null)&#123; System.out.print(root); list.push(root); root = root.left; &#125; if(!list.isEmpty())&#123; root = list.pop(); root = root.right(); &#125; &#125; &#125; 中序遍历中序遍历递归12345public void inorder(TreeNode root)&#123; inorder(root.left); System.out.print(root); inorder(root.right);&#125; 中序遍历非递归123456789101112131415public void inorder2(TreeNode root)&#123; LinkedList&lt;TreeNode&gt; list = new LinkedList&lt;&gt;(); while(root != null || !list.isEmpty())&#123; if(root != null)&#123; list.push(root); root = root.left; &#125; if(!list.isEmpty())&#123; root = list.pop(); System.out.print(root); root = root.right(); &#125; &#125;&#125; 后序遍历后序遍历递归12345public void postorder(TreeNode root)&#123; postorder(root.left); postorder(root.right); System.out.print(root);&#125; 后序遍历非递归12345678910111213141516171819202122public void postorder2(TreeNode root)&#123; LinkedList&lt;TreeNode&gt; list = new LinkedList&lt;&gt;(); LinkedList&lt;TreeNode&gt; list2 = new LinkedList&lt;&gt;(); while(root != null || !list.isEmpty()) &#123; while (root != null) &#123; list.push(root); list2.push(new Integer(0)); root = root.left; &#125; while (!list.isEmpty() &amp;&amp; list2.peek().equals(1)) &#123; list2.pop(); System.out.print(list.pop()); &#125; if (!list.isEmpty()) &#123; list2.pop(); list2.push(new Integer(1)); root = list.peek(); root = root.right; &#125; &#125; &#125; 层次遍历12345678910111213141516171819202122public void level(TreeNode root)&#123; int start = 0; int end = 1; LinkedList list = new LinkedList(); list.add(root); while(!list.isEmpty())&#123; TreeNode t = list.remove(); System.out.print(t.val); start++; if(t.left != null)&#123; list.add(t.left); &#125; if(t.right != null)&#123; list.add(t.right); &#125; if(start == end)&#123; start = 0; end = list.size()； &#125; &#125;&#125; More/(ㄒoㄒ)/~~ /(ㄒoㄒ)/~~]]></content>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的镜像]]></title>
    <url>%2F2018%2F04%2F25%2F425%2F</url>
    <content type="text"><![CDATA[题目描述 操作给定的二叉树，将其变换为源二叉树的镜像。输入描述:二叉树的镜像定义：源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 代码1234567891011/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/ 123456789101112131415public class Solution &#123; public void Mirror(TreeNode pRoot) &#123; Mirror2(root); &#125; public void Mirror2(TreeNode t)&#123; TreeNode temp = null; if(t != null)&#123; temp = t.left; t.left = t.right; t.right = temp; Mirror2(t.left); Mirror2(t.right); &#125;&#125; 思路将左右两个子树交换，递归的调用 坑1 开始的时候将Mirror2(t.left)，Mirror2(t.right)写在了外面，这样的话，会报空，因为if走完后，接着走这两条。 More感觉人生第一次用递归一次写完这个题目，并提交成功，吼开心。。。。。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对称的二叉树]]></title>
    <url>%2F2018%2F04%2F24%2F424_2%2F</url>
    <content type="text"><![CDATA[题目描述 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 代码123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 1234567891011121314151617181920212223242526272829public class Solution &#123; boolean isSymmetrical(TreeNode pRoot) &#123; TreeNode node = getMirror(pRoot); return isSymmetrical(pRoot,node); &#125; boolean isSymmetrical(TreeNode pRoot,TreeNode node) &#123; if(pRoot == null &amp;&amp; node == null)&#123; return true; &#125;else if(pRoot == null || node == null)&#123; return false; &#125; if(pRoot.val == node.val)&#123; return isSymmetrical(pRoot.left,node.left)&amp;&amp;isSymmetrical(pRoot.right,node.right); &#125; return false; &#125; TreeNode getMirror(TreeNode pRoot)&#123; if (pRoot == null) &#123; return null; &#125; TreeNode root = new TreeNode(pRoot.val); root.right = getMirror(pRoot.left); root.left = getMirror(pRoot.right); return root; &#125;&#125; 思路将树copy一份并求出其镜像树（将每个结点的左右子树交换），比较原树和镜像树的每个节点，如果全部一样，则是镜像树 坑1 getMirror()函数也是递归定义。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把二叉树打印成多行]]></title>
    <url>%2F2018%2F04%2F24%2F424%2F</url>
    <content type="text"><![CDATA[题目描述 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 代码1234567891011public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334/** 队列LinkedList完成层序遍历，用end记录每层结点数目*/public class Solution &#123; ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); if(pRoot == null)&#123; return result; &#125; Queue&lt;TreeNode&gt; layer = new LinkedList&lt;TreeNode&gt;(); ArrayList&lt;Integer&gt; layerList = new ArrayList&lt;Integer&gt;(); layer.add(pRoot); int start = 0, end = 1; while(!layer.isEmpty())&#123; TreeNode cur = layer.remove(); layerList.add(cur.val); start++; if(cur.left!=null)&#123; layer.add(cur.left); &#125; if(cur.right!=null)&#123; layer.add(cur.right); &#125; //判断start是否end,来确定一层一行 if(start == end)&#123; end = layer.size(); start = 0; result.add(layerList); layerList = new ArrayList&lt;Integer&gt;(); &#125; &#125; return result; &#125;&#125; 思路这个一个层次遍历的应用，中间需要记录每一行的开始（start）和结束（end），来确定一层输出一行。 坑1 我最开始的想法是每一个节点对应一个数字（行号）确定他是在哪一行，等到对应节点的行号与下一个节点不一样的时候，就换行。与上面的代码区别是多了一个ArrayList，记录好多不需要的信息，浪费了。 知识点1 层次遍历 层次遍历，底层就是一个队列。算法思路是： 先将二叉树头节点入队列，然后出队列，访问该节点，如果它有左子树，则将左子树根节点入队，如果它有右子树，则将右子树根节点入队。然后出队列，对出队列节点访问，如此反复，直到队列为空为止。 More代码中是通过LinkedList模拟队列的，Java把队列，栈等数据结构封装的很好，但是最好还是要自己来理解实现一下这些底层。最近有看redis，里面很多操作的底层也是这些基础。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的下一个结点]]></title>
    <url>%2F2018%2F04%2F23%2F424_1%2F</url>
    <content type="text"><![CDATA[题目描述 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 代码12345678910public class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213141516public class Solution &#123; TreeLinkNode GetNext(TreeLinkNode node) &#123; if(node==null) return null; if(node.right!=null)&#123; //如果有右子树，则找右子树的最左节点 node = node.right; while(node.left!=null) node = node.left; return node; &#125; while(node.next!=null)&#123; //没右子树，则找第一个当前节点是父节点左孩子的节点 if(node.next.left==node) return node.next; node = node.next; &#125; return null; //退到了根节点仍没找到，则返回null &#125;&#125; 思路 坑1 对应图片中的b）开始没有思考的那么透彻，像j节点，和M节点开始都是迷糊的。 知识点1 中序遍历 如果二叉树为空树，则什么都不做；否则： 先序遍历左子树 访问根节点 先序遍历右子树 More图片是出自小河沟大河沟]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重建二叉树]]></title>
    <url>%2F2018%2F04%2F20%2F420_1%2F</url>
    <content type="text"><![CDATA[题目描述 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 代码123456789/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */ 12345678910111213141516171819202122232425public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; TreeNode root=reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1); return root; &#125; //前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125; private TreeNode reConstructBinaryTree(int [] pre,int startPre,int endPre,int [] in,int startIn,int endIn) &#123; //如果树为空 if(startPre&gt;endPre||startIn&gt;endIn) return null; //根据先序遍历确定root节点 TreeNode root=new TreeNode(pre[startPre]); //递归：分别确定左子树和右子树 for(int i=startIn;i&lt;=endIn;i++) //确定子树的root节点 if(in[i]==pre[startPre])&#123; //左 root.left=reConstructBinaryTree(pre,startPre+1,startPre+i-startIn,in,startIn,i-1); //右 root.right=reConstructBinaryTree(pre,i-startIn+startPre+1,endPre,in,i+1,endIn); break; &#125; return root; &#125;&#125; 思路根据先序确定根节点，查找对应中序中位置，在中序位置左边为左子树，右边为右子树，递归调用。 坑1 已经忘了如何根据前序和中序确定一棵树 知识点1 先序遍历（前序遍历） 如果二叉树为空树，则什么都不做；否则： 访问根节点 先序遍历左子树 先序遍历右子树 2 中序遍历 如果二叉树为空树，则什么都不做；否则： 先序遍历左子树 访问根节点 先序遍历右子树 3 后续遍历 如果二叉树为空树，则什么都不做；否则： 先序遍历左子树 先序遍历右子树 访问根节点 More回看树，其实树里有好多东西的]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表总结]]></title>
    <url>%2F2018%2F04%2F20%2F420%2F</url>
    <content type="text"><![CDATA[链表是一种递归的数据机构，它或者为空(null)，或者是指向一个节点(node)的引用，该节点含有一个泛型的元素和一个指向另一条链表的引用。 抽象数据类型1234567891011/*** public class ListNode &#123;* Object val;* ListNode next = null;** ListNode() &#123; &#125;* ListNode(Object val) &#123;* this.val = val;* &#125;* &#125;*/ 上述代码定义了ListNode对象，有两个实例变量，val和next，val类型是任何你希望的数据类型（这里用了Object），next指下一个节点（默认为null）。这个定义可能会有写费解，因为这个是一个递归的数据结构。 链表的操作表头插入节点123ListNode oldfirst = first;first = new ListNode();first.next = oldfirst; 表头删除节点1first = first.next; 表尾插入节点123oldlast = last;last = new ListNode();oldlast.next = last; 如何学好链表可以和这位学下。也可以像算法第四版用链表实现一个栈、队列。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表中环的入口结点]]></title>
    <url>%2F2018%2F04%2F19%2F419_1%2F</url>
    <content type="text"><![CDATA[题目描述 一个链表中包含环，请找出该链表的环的入口结点。 代码12345678910/* public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/ 123456789101112131415import java.util.ArrayList;public class Solution &#123; public ListNode EntryNodeOfLoop(ListNode pHead) &#123; ArrayList&lt;ListNode&gt; list = new ArrayList&lt;ListNode&gt;(); if(pHead == null) return null; while(!list.contains(pHead))&#123; list.add(pHead); pHead = pHead.next; if(pHead == null) return null; &#125; return pHead; &#125;&#125; 思路遍历一遍链表，并将每个节点存入ArrayList,如果遍历过程中发现ArrayList已经存在当前节点，那说明这个就是我们要找的节点 坑1 题目说是链表有环，但是提交代码后，发现要判断这个链表有没有环。 知识点1 了解下ArrayList的contain方法是怎么实现的 More看别人提交的代码，像是在解一道数学题，首先你要设x=2y，然后回推，效率是高的，复杂度也低，但是耗脑子，可以学习一波。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从尾到头打印链表]]></title>
    <url>%2F2018%2F04%2F19%2F419%2F</url>
    <content type="text"><![CDATA[题目描述 输入一个链表，从尾到头打印链表每个节点的值。 代码1234567891011/*** public class ListNode &#123;* int val;* ListNode next = null;** ListNode(int val) &#123;* this.val = val;* &#125;* &#125;**/ 123456789101112131415161718192021import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; //存取链表中的数据 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //存取list的反向数据 ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); //如果为空，啥也不做 if(listNode == null) &#123; return list1; &#125; while(listNode!=null) &#123; list.add(listNode.val); listNode = listNode.next; &#125; for(int i = list.size()-1;i&gt;=0;i--) &#123; list1.add(list.get(i)); &#125; return list1; &#125;&#125; 思路链表读取存储到ArrayList中，然后再从ArrayList反向读取存储到另一个ArrayList（就是栈的操作） 坑1 我不是很确定空的ArrayList输出是什么，是”[]”; 知识点1 链表]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除链表中重复的结点]]></title>
    <url>%2F2018%2F04%2F18%2F418%2F</url>
    <content type="text"><![CDATA[题目描述 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 代码12345678910/* public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/ 12345678910111213141516171819202122public class Solution &#123; public ListNode deleteDuplication(ListNode pHead) &#123; ListNode result; ListNode temp = pHead; ListNode index = new ListNode(1); index.next = pHead; result = index; while (temp != null) &#123; if (temp.next != null &amp;&amp; temp.next.val == temp.val) &#123; while (temp.next != null &amp;&amp; temp.next.val == temp.val) &#123; temp = temp.next; &#125; temp = temp.next; index.next = temp; &#125; else &#123; index = index.next; temp = temp.next; &#125; &#125; return result.next; &#125;&#125; 坑1 第一次提交删除了重复的节点，题目要求是所有重复的节点，一个也不留2 对于Java中引用理解需要加深3 链表的操作需要了解，这里尽管只有删除 知识点1 链表1.1 数据结构1.2 操作 2 Java中的引用]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顺时针打印矩阵]]></title>
    <url>%2F2018%2F04%2F17%2F417%2F</url>
    <content type="text"><![CDATA[题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 代码123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); //判断matrix是否为空 if(matrix == null || matrix.length == 0) return list; //matrix的行 int row = matrix.length; //matrix的列 int col = matrix[0].length; //方便矩阵的遍历 int rowStart = 0; int rowEnd = row - 1; int colStart = 0; int colEnd = col - 1; while(colStart &lt;= colEnd &amp;&amp; rowStart &lt;= rowEnd) &#123; for(int i = colStart; i &lt;= colEnd; i++) list.add(matrix[rowStart][i]); for(int i = rowStart+1; i &lt;= rowEnd; i++) list.add(matrix[i][colEnd]); //防止重复遍历 if(rowStart != rowEnd) &#123; for(int i = colEnd-1; i &gt;= colStart; i--) list.add(matrix[rowEnd][i]); &#125; //防止重复遍历 if(colStart != colEnd) &#123; for(int i = rowEnd-1; i &gt; rowStart; i--) list.add(matrix[i][colStart]); &#125; colStart++; colEnd--; rowStart++; rowEnd--; &#125; return list; &#125;&#125; 坑1 对于向量，从上到下（从左往右）和从下到上（从右往左）只要遍历一次。如：1int[][] a = &#123;&#123;1&#125;,&#123;2&#125;,&#123;3&#125;,&#123;4&#125;,&#123;5&#125;&#125; 2 很多边界例子不会考虑。 知识点1 高维数组1.1 如何定义一个二维（更高维）的数组123int[][] a = &#123;&#123;1,2,&#125;,&#123;3,4&#125;&#125;;int[][][] three = &#123;&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;,&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;&#125;;int[][] b = new int[2][2]; 1.2数组的长度12int row = matrix.length;int col = matrix[0].length; 1.3 java Arrays.deepToString()函数将高维数组字符串化 今天人生第一次来做这种题目，说实话不会做，做了会有很多错，尽管看起来很简单。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这几天]]></title>
    <url>%2F2018%2F01%2F22%2F1.22%2F</url>
    <content type="text"><![CDATA[好多天没有来玩博客，Markdown的语法也忘了，hexo的命令也忘了，导师的教我写的东西，一个月没碰了，啥啥啥都忘了。。。。 前几天无聊看了一波python文档，把廖老师写的文档和《简明Python教程》过了一遍，然后发现这是一个神奇的世界。 恩，写这个文章，其实也不是说我要介绍我这天的心得体会，就只是来冒个泡，写文章真的需要坚持，如果你不是职业的话，而且，我发现的我不知道写啥，内心啥也木有， 这几天看了一波吐槽大会，interesting，哈哈哈哈哈哈哈哈，然后还去下了一波《手把手教你脱口秀》，好有意思。 我还准备买个陶笛，人生最大的梦想，懂一波音乐。 这几天，大家都放假，氛围特别浓重，说实话，我都给自己放一个月了。。。。 不知道自己写了什么，就当记录一下吧，byebye。。。。。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多个电脑一起写blog]]></title>
    <url>%2F2018%2F01%2F13%2Fblog%2F</url>
    <content type="text"><![CDATA[你是不是也有这样子的问题，如果台式机可以写博客上传，那笔记本想写怎么办呢？我来告诉你。 传送门送上：1，2第一篇的文章比较短，但是就是精华，第二篇，有部分图文，会给你一些更直观的参考。 我呢，还是给大家一些建议 不要怕出错，说实话，对于一个小白来说，什么也不懂，什么是git啊，没关系，不要担心，要相信自己。 尽管你可能不懂git,可是这玩意还是不得不学的额，常见的命令 git pull origin hexo: 本机同步GitHub里的文章 git push origin hexo: 上传文章到GitHub]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的使用]]></title>
    <url>%2F2018%2F01%2F13%2Fnote%2F</url>
    <content type="text"><![CDATA[配置用户名和Email$ git config –global user.name “Your Name”$ git config –global user.email “email@example.com” 创建版本库初始化一个Git仓库，使用git init命令。添加文件到Git仓库，分两步： 第一步，使用命令git add ，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit -m “”，完成。 vim的使用i 进入输入模式ESC 退出输入模式，进入命令模式:wq 保存修改并退出vim 状态的查看和比较 比较 git diff 查看 git status 文件名 版本回退 查看历史 git log/git log –pretty=online当前版本用HEAD表示，HEAD^表示上一个版本，HEAD^^表示上上版本，HEAD~100表示上100个版本 回退到当前版本的上一个版本 git reset –hard HEAD^当你回退到以前版本，那当前版本会不见，可以使用 git reset –hard (commit id)来恢复 记录执行的每一次命令 git reflog通过此条命令可以查看到各个版本commit id HEAD指向当前版本git log 查看提交历史git reflog 查看命令历史 工作区和暂存区 工作区(Working Directory)就是当前目录 版本库(Repository)工作区中隐藏目录.git,Git的版本库版本库中有：暂存区、第一个分支master、指向master的一个指针HEAD 暂存区(Stage)把文件往Git版本库里添加的时候，分为两步第一步：git add，意义是把文件添加到暂存区第二步: git commit,意义是将暂存区的所有内容提交到当前分支开始默认我们在master分支 Git是如何跟踪修改的：每次修改，如果不add到暂存区，那就不会加入到commit中。 撤销和修改命令是：git checkout – filename file自修改后还没有被放到暂存区，使用命令后，返回版本库的状态 file已经添加到了暂存区，又作了修改，使用命令后，返回暂存区的状态总之，是文件返回最近一次git commit 或 git add 的状态 命令：git reset HEAD file指的是把暂存区的修改撤销，回到工作区的版本git reset 既可以回退版本，也可以把暂存区的修改回退到工作区。 总结： 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 删除文件将已经提交到版本库的文件删除，需要同步git git rm file git commit -m “”如果是误删git checkout – file 添加远程仓库 要关联一个远程库，使用命令**git remote add origin git@server-name:path/repo-name.git; 关联后，使用命令git push -u origin master 第一次推送master分支的所有内容; 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改; Tipsssh:是一个安全协议，git支持git协议。第一次使用ssh的时候，需要设置公钥和私钥，命令是 ssh-keygen -t rsa -C “youremail@example.com”对应的在用户主目录中会生成.ssh目录，目录中有id_rsa和id_rsa.pub两个文件 clone远程库命令是git clone git@server-name:path/repo-name.gitgit支持多种协议，包括https，ssh 等等 创建与合并分支 git checkout -b dev:创建了dev分支命令等同于：git branch dev ; git checkout dev git branch:查看当前分支，罗列出所有分支 git merge dev:将dev分支的工作成果合并到当前分支上 git branch -d dev:删除dev分支 解决冲突当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。用git log –graph命令可以看到合并图。好看一点用git log –graph –pretty=oneline –abbrev -commit 分支策略 master分支用来发布新版本，平时不东 dev分支是用来干活的，干完活和master合并 每个团队成员创建自己的分支，是不是和dev分支合并 合并时，默认是fast forward合并，合并后删除分支后看不出是合并的，会丢失信息，加上–nn-ff参数就可以使用普通模式合并 Bug分支当我们遇到bug需要修复，手头的任务又没有做完，我们可以使用git stash来保护现场，类似于进程中断。当我们修复好bug后，我们可以用git stash list查看工作现场。 git stash git stash list git stash apply:恢复现场，但不删除stash git stash drop:删除stash git stash pop:等于上两步 feature分支开发一个新feature，最好创建一个分支；如果要丢弃一个没有被合并过的分支，可以通过git branch -D name 强行删除。 多人协作 git remote :用于查看远程库的信息 git remote -v :用于查看远程库的详细信息 git push origin master/dev :master分支需要和远程同步，dev分支也一样，bug分支不需要，feature分支看情况]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echo xi]]></title>
    <url>%2F2018%2F01%2F13%2Ffirst%2F</url>
    <content type="text"><![CDATA[xixiOK? 你知道吗？ 我看别人的博客都是名言警句随口来，我呢，刚刚憋了许久，木有啊！！ /(ㄒoㄒ)/~~]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Me]]></title>
    <url>%2F2018%2F01%2F13%2FMe%2F</url>
    <content type="text"><![CDATA[Hey,大家好！！！你们可以叫我echo，这是三毛的英文名，感觉三毛和荷西的爱情很酷，所以我随了三毛。]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何建立一个独立博客]]></title>
    <url>%2F2018%2F01%2F12%2Fhexo-github%2F</url>
    <content type="text"><![CDATA[我来猜一猜你为什么要建博客：装逼，找个地方发泄，无聊。。。如果不对，你可以留言告诉我 ^_^ 前言如果你是小白，那你肯定会受好多挫，你可以百度也可以Google，当然我希望什么也不要遇到，因为我会告诉你所有可能的错，别问我为什么 o(╥﹏╥)o what you need ? git hexo github 这三个是啥呢？github，类似于一个服务器，这样别人就可以在网上找到你的博客，当然你也可以自己买服务器。hexo，模板，就是博客显示页面的样子，有好多好人已经写好了很多好看的模板，你挑一个喜欢的，当然你也可以自己写！git，上传工具，就是把你写好的东西，上传到网上。 安装gitGit下载:下载完就可以安装了，一路next 结束安装，检查自己有木有成功，Win+R，cmd 如果看见版本号，就成功啦！！是不是很惊喜，很开心，吼简单哦！！ 安装hexo恩~，这个地方有点烦的，请注意！！！官网：官方文档：很详细，可以仔细学习一波。我呢，就给一些注意事项 先要安装Node.js 在任何地方(比如桌面)右击，点击 git bash here，在输入 npm install -g hexo-cli 回车，输入画面如图： hexo是使用Markdown解析文章的，那标记后面需要一个空格图片中每个key后面都有空格，图中的绿色方框，有点大小不一，但都代表一个空格 最后写完文章部署的时候，可以用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d一条命令我在写这个文档的时候，也重看了一边官网，虽说很详细，带我不想看啊，好烦啊，好烦啊，与木有这种感觉，o(╥﹏╥)o GitHub这个真的是一个好神奇的地方，抄作业的好地方，代码不会写，来抄一波，没有灵感，来搜一波，比什么百度靠谱多了。来一个传送门，这篇文章在这儿写的很详细贴心，最主要页面看的不是那么难看。 OK我想你已经完成你的博客的建立了，是不是很happy，我当时就老happy了，可是，记住写博客还是一件很艰难的事，时间久了，人就懒了，就不写了。当然，我知道说的不是你，(#^.^#)]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown的使用]]></title>
    <url>%2F2018%2F01%2F12%2FMarkdown%2F</url>
    <content type="text"><![CDATA[Markdown的好处 比纯文本排版显示的好看 比Word排版显示简单 学起来简单 学习资料 Markdown中文版语法说明 博客1 博客2 建议 不用什么语法都学，学几个常用的就可以，比如标题，粗体，斜体。 你可以用通用文本编辑器：notepad++，sublime，也可以用专用的MarkPad,Mou。 祝你开心每一天！！！(^▽^)]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
