---
title: 重建二叉树 
date: 2018-04-20 12:02:33
tags: [树]
categories: algorithm
---
# 题目描述
> 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

# 代码
```java
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
```
<!--more-->

```java
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        TreeNode root=reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1);
        return root;
    }
    //前序遍历{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}
    private TreeNode reConstructBinaryTree(int [] pre,int startPre,int endPre,int [] in,int startIn,int endIn) {
        //如果树为空 
        if(startPre>endPre||startIn>endIn)
            return null;
        //根据先序遍历确定root节点
        TreeNode root=new TreeNode(pre[startPre]);
        //递归：分别确定左子树和右子树
        for(int i=startIn;i<=endIn;i++)
   			//确定子树的root节点
            if(in[i]==pre[startPre]){
            	//左
                root.left=reConstructBinaryTree(pre,startPre+1,startPre+i-startIn,in,startIn,i-1);
                //右
                root.right=reConstructBinaryTree(pre,i-startIn+startPre+1,endPre,in,i+1,endIn);
                break;
            }
        return root;
    }
}
```
# 思路
根据先序确定根节点，查找对应中序中位置，在中序位置左边为左子树，右边为右子树，递归调用。

# 坑
1 已经忘了如何根据前序和中序确定一棵树

# 知识点
1 先序遍历（前序遍历）
- 如果二叉树为空树，则什么都不做；否则：
	- 访问根节点
	- 先序遍历左子树
	- 先序遍历右子树

2 中序遍历
- 如果二叉树为空树，则什么都不做；否则：
	- 先序遍历左子树
	- 访问根节点
	- 先序遍历右子树

3 后续遍历
- 如果二叉树为空树，则什么都不做；否则：
	- 先序遍历左子树
	- 先序遍历右子树
	- 访问根节点

# More
回看树，其实树里有好多东西的
