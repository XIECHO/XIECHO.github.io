---
title:  剑指offer_503
date: 2018-05-03 13:31:21
tags: 
categories: algorithm
---
# 题目描述
> 将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0

# ascii码表
数字0-9：48-57
字母A-Z：65-90
字母a-z：97-122

# 字符串中的"==" 和 equals（）的的区别
我会很习惯的认为两个字符串用"=="，这个是比较地址，不是比较内容，内容用equals（）

# 代码
```java
public class Solution
{
    public int StrToInt(String str)
    {
        if(str.equals(""))
            return 0;
        char[] st = str.toCharArray();
        int fuhao = 0;
        if(st[0] == '-'){
            fuhao = 1;
        }
        int sum = 0;
        for(int i = fuhao; i < st.length; i++){
            if(st[i] == '+')
                continue;
            if(st[i] < 48 || st[i] > 58)
                return 0;
            sum = 10 * sum + st[i] - 48;
        }
        return fuhao == 0 ? sum : sum * -1; 
    }
}
```
<!--more-->


# 题目描述
> 输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。

# 代码
```java
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> FindNumbersWithSum(int [] array,int sum) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        int start = 0;
        int end = array.length - 1;
        while(start < end){
            if(array[start] + array[end] == sum){
                list.add(array[start]);
                list.add(array[end]);
                return list;
            }else if(array[start] + array[end] > sum){
                end--;
            }else{
                start++;
            }
        }
        return list;
    }
}
```
# 思路
# 题目描述
> 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？


# 代码
```java
public class Solution {
    public String ReverseSentence(String str) {
        String[] sp = str.split(" ");
        String temp = "";
         if(str.trim().equals("")){
            return str;
        }
        for(int i = sp.length -1; i >= 0;i--){
            if(i == 0){
                temp = temp + sp[i];
                break;
            }
            temp = temp + sp[i]+" ";
        }
        return temp;
    }
}
```
# 题目描述
> 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

# 代码
```java
import java.util.*;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public int TreeDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        int count = 0;
        LinkedList<TreeNode> list = new LinkedList<>();
        list.add(root);
        int start = 0;
        int end = 1;
        while(!list.isEmpty()){
            root = list.remove();
            start ++;
            if(root.left != null){
                list.add(root.left);
            }
            if(root.right != null){
                list.add(root.right);
            }
            if(start == end){
                count ++;
                start = 0;
                end = list.size();
            }
        }
        return count;
    }
}
```

# 题目描述
> 统计一个数字在排序数组中出现的次数。

# 代码
```java
public class Solution {
    public int GetNumberOfK(int[] array, int k) {
        int length = array.length;
        int start = 0;
        int end = length - 1;
        int mid = (end + start) / 2;
        int temp = -1;
        int count = 0;
        while (end >= start) {
            if (array[mid] == k) {
                temp = mid;
                break;
            } else if (array[mid] > k)
                end = mid - 1;
            else
                start = mid + 1;
            mid = (end + start) / 2;
        }

        if (temp == -1) {
            return 0;
        } else {

            for (int i = temp; i >= 0; i--) {
                if (array[i] == k) {
                    count++;
                } else {
                    break;
                }
            }
            for (int j = temp + 1; j < length; j++) {
                if (array[j] == k) {
                    count++;
                } else {
                    break;
                }
            }
            return count;
        }
    }
}
```

# 题目描述
> 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！

# 代码
```java
public class Solution {
    public String LeftRotateString(String str,int n) {
        char[] st = str.toCharArray();
         if(str.equals(""))
            return str;
        if(st.length < n)
            n = n%st.length;
        String s  = "";
        for(int i = n; i<st.length; i++){
            s = s + st[i];
        }
        for(int i = 0; i<n; i++){
            s = s + st[i];
        }
        return s;
    }
}
```

# 题目描述
> 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

# 代码
```java
public class Solution {
    public boolean IsPopOrder(int[] pushA, int[] popA) {
        LinkedList<Integer> list = new LinkedList<>();
        for (int i = 0, j = 0; i < pushA.length; i++) {
            list.add(pushA[i]);
            while (j < popA.length && list.getLast() == popA[j]) {
                list.removeLast();
                j++;
            }
        }
        if (list.isEmpty()) {
            return true;
        } else {
            return false;
        }
    }
}

```



