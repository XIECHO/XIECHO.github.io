---
title:  剑指offer_504
date: 2018-05-04 13:31:21
tags: 
categories: algorithm
---
# 题目描述
> 输入一个链表，输出该链表中倒数第k个结点。

# 代码
```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        ListNode first  = head; 
        for(int i = 0; i<k; i++){
            if(head == null){
                return null;
            }
            head = head.next;
        }
        
        while(head != null){
            head = head.next;
            first = first.next;
        }
        return first;

    }
}
```
<!--more-->


# 题目描述
> 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

# 代码
```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        ListNode head = new ListNode(0);
        ListNode list = head;
           
        while(list1 != null && list2 != null){
            if(list1.val <= list2.val){
                list.next = list1;
                list = list.next;
                list1 = list1.next;
            }else{
                list.next = list2;
                list = list.next;
                list2 = list2.next;
            }
        }

        if(list1 != null){
            list.next = list1;
        }else{
            list.next = list2;
        }
        return head.next;
    }
}
```
# 思路
# 题目描述
> 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。


# 代码
```java
import java.util.ArrayList;
import java.util.List;
public class Solution {
    public void reOrderArray(int [] array) {
      List<Integer> list1 = new ArrayList<Integer>();
      List<Integer> list2 = new ArrayList<Integer>();
      for(int i=0;i<array.length;i++){
          if(array[i]%2==0){
              list2.add(array[i]);  
          }else{
              list1.add(array[i]);  
          }
      }
      for(int i=0;i<list1.size();i++){
          array[i] = list1.get(i);
      }
      for(int i=list1.size(),j=0;i<list1.size()+list2.size();i++,j++){
          array[i] = list2.get(j);
      }
    }
}
```
# 题目描述
> 输入一个链表，反转链表后，输出链表的所有元素。

# 代码
```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode ReverseList(ListNode head) {
        ListNode newHead = null;
        ListNode first = null;
        while(head != null){
            newHead = head.next;
            head.next = first;
            first =  head;
            head = newHead;
        }
        return first;
    }
}
```

# 题目描述
> 统计一个数字在排序数组中出现的次数。

# 代码
```java
public class Solution {
    public int GetNumberOfK(int[] array, int k) {
        int length = array.length;
        int start = 0;
        int end = length - 1;
        int mid = (end + start) / 2;
        int temp = -1;
        int count = 0;
        while (end >= start) {
            if (array[mid] == k) {
                temp = mid;
                break;
            } else if (array[mid] > k)
                end = mid - 1;
            else
                start = mid + 1;
            mid = (end + start) / 2;
        }

        if (temp == -1) {
            return 0;
        } else {

            for (int i = temp; i >= 0; i--) {
                if (array[i] == k) {
                    count++;
                } else {
                    break;
                }
            }
            for (int j = temp + 1; j < length; j++) {
                if (array[j] == k) {
                    count++;
                } else {
                    break;
                }
            }
            return count;
        }
    }
}
```

# 题目描述
> 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！

# 代码
```java
public class Solution {
    public String LeftRotateString(String str,int n) {
        char[] st = str.toCharArray();
         if(str.equals(""))
            return str;
        if(st.length < n)
            n = n%st.length;
        String s  = "";
        for(int i = n; i<st.length; i++){
            s = s + st[i];
        }
        for(int i = 0; i<n; i++){
            s = s + st[i];
        }
        return s;
    }
}
```

# 题目描述
> 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

# 代码
```java
public class Solution {
    public boolean IsPopOrder(int[] pushA, int[] popA) {
        LinkedList<Integer> list = new LinkedList<>();
        for (int i = 0, j = 0; i < pushA.length; i++) {
            list.add(pushA[i]);
            while (j < popA.length && list.getLast() == popA[j]) {
                list.removeLast();
                j++;
            }
        }
        if (list.isEmpty()) {
            return true;
        } else {
            return false;
        }
    }
}

```



