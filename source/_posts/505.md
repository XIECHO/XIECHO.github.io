---
title:  剑指offer_505  
date: 2018-05-05 8:48:21
tags: 
categories: algorithm
---
# 题目描述
> 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

# 代码
```java
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if(array.length == 0){
            return 0;
        }
        for(int i = 0; i < array.length - 1; i++){
            if(array[i] > array[i + 1]){
                return array[i + 1];
            }
        }
        return array[0];
    }
}
```
<!--more-->


# 题目描述
> 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。


# 代码
```java
/*
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();

    public void push(int node) {
        stack1.push(node);
    }

    public int pop() {
        if (stack2.isEmpty() && stack1.isEmpty()) {
            return 0;
        } else {
            if (stack2.isEmpty()) {
                while (!stack1.isEmpty()) {
                    stack2.push(stack1.pop());
                }
                return stack2.pop();
            } else {
                return stack2.pop();
            }
        }
    }
}
```
# 思路
# 题目描述
> 定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。


# 代码
```java
import java.util.Stack;

public class Solution {

    Stack<Integer> data = new Stack<Integer>();
    Stack<Integer> min = new Stack<Integer>();
    Integer temp = null;
    public void push(int node) {
       if(temp != null){
           if(temp >= node){
               temp = node;
               min.push(node);
           }
           data.push(node);
       }else{
           temp = node;
           min.push(node);
           data.push(node);
       }
    }
    
    public void pop() {
        int num = data.pop();
        int num2 = min.pop();
        if(num != num2){
            min.push(num2);
        }
    }
    
    public int top() {
        return data.peek();
    }
    
    public int min() {
        int num = min.pop();
        min.push(num);
        return num;
    }
}
```
# 题目描述
> 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

# 代码
```java
public class Solution {
    public int NumberOf1(int n) {
        String ns = Integer.toBinaryString(n);
        char[] nsc = ns.toCharArray();
        int count = 0;
        for(char temp : nsc){
            if(temp == '1')
                count++;
        }
        return count;
    }
}
```

# 题目描述
> 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。

# 代码
```java
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        
        for(int i = 0 ; i < array.length; i++){
            for(int j = 0 ; j < array.length -1 -i; j++){
                if(array[j] < array[j+1]){
                    int temp = array[j];
                    array[j] = array[j+1];
                    array[j+1] = temp;
                }
            }
        }
        int count =0;
        int temp = array[0];
        for(int i = 0; i<array.length; i++){
            if(array[i] == temp){
                ++count;
                if(count > array.length/2){
                   return temp;
                }
            }else{
                if(count > array.length/2){
                    return temp;
                }else{
                    temp = array[i];
                    count = 1;
                }
            }
        }
        return 0;
    }
}
```

# 题目描述
> 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。

# 代码
```java
import java.util.*;
public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
       for(int i = 0; i<input.length; i++){
           for(int j = 0; j < input.length-1-i; j++){
               if(input[j] > input[j+1]){
                   int temp = input[j];
                   input[j] = input[j+1];
                   input[j+1] = temp;
               }
           }
       }
         ArrayList<Integer> list = new ArrayList<>();
        if(k > input.length){
            return list;
        }
        
       
        for(int i = 0; i<k;i++){
            list.add(input[i]);
        }
        return list;
    }
}
```

# 题目描述
> 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

# 代码
```java
import java.util.Arrays;
import java.util.Comparator;

public class Solution {
    public String PrintMinNumber(int [] numbers) {
        String[] snum = new String[numbers.length];
        for (int i = 0; i < numbers.length; i++) {
            snum[i] = String.valueOf(numbers[i]);
        }

        Arrays.sort(snum, new Comparator<String>() {
             public int compare(String s1, String s2) {
                String c1 = s1 + s2;
                String c2 = s2 + s1;
                return c1.compareTo(c2);
            }
        });
        String last = "";
        for (String temp : snum) {
            last = last + temp;
        }
        return last;
    }
}
```


# 题目描述
> 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。

# 代码
```java
public class Solution {
    public int NumberOf1Between1AndN_Solution(int n) {
        String temp = "";
        int count = 0;
        for(int i = 1; i <= n; i++){
            temp = String.valueOf(i);
            while(temp.contains("1")){
                 count++;
                temp = temp.substring(temp.indexOf('1')+1);
            }
        }
        return count;
    }
}
```

# 题目描述
> 把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。
# 代码
```java
import java.util.*;
public class Solution {
    public int GetUglyNumber_Solution(int index) {
        if (index < 7)
        return index;
        int[] ret = new int[index];
        ret[0] = 1;
        int t2 = 0, t3 = 0, t5 = 0;
        for (int i = 1; i < index; i++) {
            ret[i] = min(min(ret[t2] * 2, ret[t3] * 3), ret[t5] * 5);
            if (ret[i] == ret[t2] * 2)
                t2++;
            if (ret[i] == ret[t3] * 3)
                t3++;
            if (ret[i] == ret[t5] * 5)
                t5++;
        }
        return ret[index - 1];
    }
    
      public static int min(int a,int b) {
        return a<b ? a : b; 
    }
}
```
