---
title:  剑指offer_506
date: 2018-05-06 8:48:21
tags: 
categories: algorithm
---
# 题目描述
> 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？
# 代码
```java
public class Solution {
    public int movingCount(int threshold, int rows, int cols)
    {
        boolean[][] visited = new boolean[rows][cols];
        return count(threshold, rows, cols, 0, 0, visited);
    }
    
    public static int count(int threshold, int rows, int cols, int r, int c, boolean[][] visited){
        if(r < 0 || r >= rows || c < 0 || c >= cols || visited[r][c] == true || sum(c) + sum(r) > threshold)
            return 0;
        visited[r][c] = true;
        return count(threshold, rows, cols, r+1, c, visited) + count(threshold, rows, cols, r-1, c, visited) 
            + count(threshold, rows, cols, r, c+1, visited) + count(threshold, rows, cols, r, c-1, visited) + 1;
    }
    
    public static int sum(int value){
        int sumValue = 0;
        while(value != 0){
            sumValue = sumValue + value % 10;
            value = value / 10;
        }
        return sumValue;
    }
}
```
<!--more-->


# 题目描述
> 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串"bcced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。

# 代码
```java
/*
public class Solution {
    public boolean hasPath(char[] matrix, int rows, int cols, char[] str)
    {
        boolean[] visited = new boolean[matrix.length];
        int k = 0;
        for(int i = 0; i<rows; i++){
            for(int j = 0; j<cols; j++){
                if(find(matrix, rows, cols, str, i, j, 0, visited))
                    return true;
            }
        }
        return false;
    }
    
    public boolean find(char[] matrix, int rows, int cols, char[] str, int i, int j,int k, boolean[] visited){
        int loc = i * cols + j ;
        if(i < 0 || i >= rows || j < 0 || j >= cols || visited[loc] || str[k] != matrix[loc])
            return false;
        if(k == str.length - 1) return true;
        visited[loc] = true;
        k++;
        if(find(matrix, rows, cols, str, i+1, j, k, visited) || find(matrix, rows, cols, str, i, j+1, k, visited)
          || find(matrix, rows, cols, str, i-1, j, k, visited)|| find(matrix, rows, cols, str, i, j-1, k, visited)){
          return true;
        }
        visited[loc] = false;
        
        return false;
    }
}
```
# 思路
# 题目描述
> 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。

# 坑
引用的问题
# 代码
```java
import java.util.*;
public class Solution {
    public ArrayList<Integer> maxInWindows(int [] num, int size)
    {
        LinkedList<Integer> list = new LinkedList<>();
        
        ArrayList<Integer> max = new ArrayList<>();
        
        for(int i = 0; i < num.length; i++){
            list.add(num[i]);
            if(list.size() == size){
                max.add(max(list));
                list.removeFirst();
            }
        }
        return max;
    }
    
    public static int max(LinkedList<Integer> list){
        LinkedList<Integer> list1 = new LinkedList<>();
        for(Integer i : list) {
            list1.add(i);
        }
        Collections.sort(list1);
        return list1.getLast();
    }
}
```
# 题目描述
> 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

# 代码
```java
public class Solution {
    public int NumberOf1(int n) {
        String ns = Integer.toBinaryString(n);
        char[] nsc = ns.toCharArray();
        int count = 0;
        for(char temp : nsc){
            if(temp == '1')
                count++;
        }
        return count;
    }
}
```

# 题目描述
> 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。

# 代码
```java
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        
        for(int i = 0 ; i < array.length; i++){
            for(int j = 0 ; j < array.length -1 -i; j++){
                if(array[j] < array[j+1]){
                    int temp = array[j];
                    array[j] = array[j+1];
                    array[j+1] = temp;
                }
            }
        }
        int count =0;
        int temp = array[0];
        for(int i = 0; i<array.length; i++){
            if(array[i] == temp){
                ++count;
                if(count > array.length/2){
                   return temp;
                }
            }else{
                if(count > array.length/2){
                    return temp;
                }else{
                    temp = array[i];
                    count = 1;
                }
            }
        }
        return 0;
    }
}
```

# 题目描述
> 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。

# 代码
```java
import java.util.*;
public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
       for(int i = 0; i<input.length; i++){
           for(int j = 0; j < input.length-1-i; j++){
               if(input[j] > input[j+1]){
                   int temp = input[j];
                   input[j] = input[j+1];
                   input[j+1] = temp;
               }
           }
       }
         ArrayList<Integer> list = new ArrayList<>();
        if(k > input.length){
            return list;
        }
        
       
        for(int i = 0; i<k;i++){
            list.add(input[i]);
        }
        return list;
    }
}
```

# 题目描述
> 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

# 代码
```java
import java.util.Arrays;
import java.util.Comparator;

public class Solution {
    public String PrintMinNumber(int [] numbers) {
        String[] snum = new String[numbers.length];
        for (int i = 0; i < numbers.length; i++) {
            snum[i] = String.valueOf(numbers[i]);
        }

        Arrays.sort(snum, new Comparator<String>() {
             public int compare(String s1, String s2) {
                String c1 = s1 + s2;
                String c2 = s2 + s1;
                return c1.compareTo(c2);
            }
        });
        String last = "";
        for (String temp : snum) {
            last = last + temp;
        }
        return last;
    }
}
```


# 题目描述
> 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。

# 代码
```java
public class Solution {
    public int NumberOf1Between1AndN_Solution(int n) {
        String temp = "";
        int count = 0;
        for(int i = 1; i <= n; i++){
            temp = String.valueOf(i);
            while(temp.contains("1")){
                 count++;
                temp = temp.substring(temp.indexOf('1')+1);
            }
        }
        return count;
    }
}
```

# 题目描述
> 把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。
# 代码
```java
import java.util.*;
public class Solution {
    public int GetUglyNumber_Solution(int index) {
        if (index < 7)
        return index;
        int[] ret = new int[index];
        ret[0] = 1;
        int t2 = 0, t3 = 0, t5 = 0;
        for (int i = 1; i < index; i++) {
            ret[i] = min(min(ret[t2] * 2, ret[t3] * 3), ret[t5] * 5);
            if (ret[i] == ret[t2] * 2)
                t2++;
            if (ret[i] == ret[t3] * 3)
                t3++;
            if (ret[i] == ret[t5] * 5)
                t5++;
        }
        return ret[index - 1];
    }
    
      public static int min(int a,int b) {
        return a<b ? a : b; 
    }
}
```
