---
title: 排序 
date: 2018-05-07 15:56:21
tags: 
categories: 总结
---

# 传统排序
排序对象应该是一切可以排序的对象，实现了Comparable接口的对象，文中主要用int(当然可以用泛型)
## 简单选择排序
### 思路
选择数组中最小的一个，与第一个元素交换，再选择数组中最小一个，与第二个交换，如此往复。
需要 N(N-1)/2 比较和 N 次交换

### 代码
```java
public class Sort{
	public static void selectedSort(int[] array){
		for(int i = 0; i<array.length; i++){
			int min = i;
			for(int j = i+1; j<array.length; j++){
				if(array[j] < array[min]){
					min = j;
				}
			}
			int temp = array[i];
			array[i] = array[min];
			array[min] = temp;
		}
	}
}
```
<!--more-->

## 插入排序
### 思路
将新数据插入到排好序的数组，类似于整理纸牌

### 代码
```java
public class Sort{
	public static void insertSort(int[] array) {
		for(int i = 1; i<array.length; i++) {
			int current = array[i];
			for(int j = i-1; j>=0 && array[j] > current;j--) {
				array[j+1]=array[j];
				array[j] = current;
			}
		}
	}
}
```
### More
插入排序对部分有序的数组特别有效
- 数组中每个元素距离它的最终位置都不远
- 一个有序的大数组接一个小数组
- 数组中只有几个元素的位置不正确

## 希尔排序
### 思路
要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。你将会看到，归并排序最吸引人地性质是它能够保证将任意长度为N地数组排序所需时间和NlogN成正比；缺点是它需要额外空间和N成正比。

### 代码
```java
public class Sort{
	public static void shellSort(int[] array) {
		int h = 1;
		while(h < array.length/3) h = h*3+1;
		while(h >= 1) {
			for(int i = h; i < array.length; i++) {
				int current = array[i];
				for(int j = i-h;  j >=0 && array[j] > current; j = j-h) {
					array[j+h] = array[j];
					array[j] = current;
				}
			}
			h = h/3;
		}
	}
}
```
### More
希尔排序为了加快速度简单地改进了插入排序，交换不相邻地元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。

## 归并排序
要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。你将会看到，归并排序最吸引人地性质是它能够保证将任意长度为N的数组排序所需时间和NlogN成正比，它的主要缺点则是它所需的额外空间和N成正比。

### 自顶向下的归并排序
#### 代码
```java
public class Sort{
	public static void mergeUB(int[] array) {
		mergeUB(array, 0, array.length - 1);
		
	}

	public static void mergeUB(int[] array, int start, int end) {
		if(end <= start) return;
		int mid = start + (end - start)/2;
		mergeUB(array, start, mid);
		mergeUB(array, mid+1, end);
		merge(array, start, mid, end);
		
	}

	public static void merge(int[] array, int start, int mid, int end) {
		int left = start;
		int right = mid + 1;
		int aux[] = new int[array.length];
		for (int i = start; i < array.length; i++) {
			aux[i] = array[i];
		}

		for (int i = start; i < aux.length; i++) {
			if (left > mid) {
				array[i] = aux[right++];
			} else if (right > end) {
				array[i] = aux[left++];
			} else if (aux[left] > aux[right]) {
				array[i] = aux[right++];
			} else {
				array[i] = aux[left++];
			}
		}
	}
}
```

### 自底向上的归并排序
#### 代码
```java
public class Sort{
	public static void mergeBU(int[] array) {
		for(int i=1; i<array.length; i=i+i) {
			for(int j = 0; j < array.length - i ; j = j+i+i) {
				merge(array, j, j+i-1, Math.min(j+i+i-1, array.length-1));
			}
		}
	}
	
	public static void merge(int[] array, int start, int mid, int end) {
		int left = start;
		int right = mid + 1;
		int aux[] = new int[array.length];
		for(int i=start; i<array.length; i++) {
			aux[i] = array[i];
		}
		
		for(int i=start; i<aux.length; i++) {
			if(left > mid) {
				array[i] = aux[right++];
			}else if(right > end) {
				array[i] = aux[left++];
			}else if(aux[left] > aux[right]) {
				array[i] = aux[right++];
			}else {
				array[i] = aux[left++];
			}
		}
	}
}
```
#### 注意点
merge() 函数中注意循环的开始是 i = start。

## 快速排序
### 思路
要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。你将会看到，归并排序最吸引人地性质是它能够保证将任意长度为N地数组排序所需时间和NlogN成正比；缺点是它需要额外空间和N成正比。

### 代码
```java
public class Sort{
	public static void quickSort(int[] array) {
		quickSort(array, 0, array.length - 1);
	}

	public static void quickSort(int[] array, int start, int end) {
		if(end <= start) return;
		int j = partition(array, start, end);
		quickSort(array, start, j-1);
		quickSort(array, j+1, end);
	}

	private static int partition(int[] array, int start, int end) {
		int i = start, j = end+1;
		int v = array[start];
		while(true) {
			while(array[++i] < v) if(i == end) break;
			while(v < array[--j]) if(j == start) break;
			if(i >= j) break;
			int temp = array[i];
			array[i] = array[j];
			array[j] = temp;
		}
		
		int temp = array[start];
		array[start] = array[j];
		array[j] = temp;
		return j;
	}
}
```
### More


## 堆排序
### 思路


### 代码
```java
public class Sort{
	public static void MinHeap_Sort(int array[], int n) {
		int temp = 0;
		MakeMinHeap(array, n);
		for(int i = n-1; i>0; i--) {
			temp = array[0];
			array[0] = array[i];
			array[i] = temp;
			MinHeapFixdown(array, 0, i);
		}
	}
	
	private static void MinHeapFixdown(int[] array, int i, int n) {
		int j = 2*i + 1;
		int temp = 0;
		while(j<n) {
			if(j+1 < n && array[j+1] < array[j]) {
				j++;
			}
			if(array[i] <= array[j])
				break;
			temp = array[i];
			array[i] = array[j];
			array[j] = temp;
			i = j;
			j = 2*i + 1;
		}
	}

	private static void MakeMinHeap(int[] array, int n) {
		for(int i = (n-1)/2; i>=0; i--) {
			MinHeapFixdown(array,i,n);
		}
	}
}
```
### More

# others
stack 
- peek():查看堆栈顶部的对象，但不从堆栈中移除它。
- pop():移除堆栈顶部的对象，并作为此函数的值返回该对象
- push():把项压入堆栈顶部
queue
- peek():获取但不移除此队列的头；如果此队列为空，则返回null。
- poll():获取并移除此队列的头，如果此队列为空，则返回null
- remove():获取并移除此队列的头
- offer():将指定的元素插入此队列(如果立即可行且不会违反容量限制)，当使用有容量限制的队列时，此方法通常要优于add(E)，后者可能无法插入元素，而只是抛出一个异常。
- element():获取，但是不移除此队列的头。
- add():将指定的元素插入此队列