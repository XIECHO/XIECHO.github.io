---
title: 多线程归纳
date: 2018-05-10 22:52:21
tags: 
categories: java基础
---

# 线程的创建
- 继承Thread类

```java
class MyThread extends Thread{
	public void run() {
		while(true) {
			System.out.println("MyThread类的run()方法在运行");
		}
	}
}
```

- 实现Runnable接口

```java
class MaxPriority implements Runnable{
	public void run() {
		for(int i=0; i<10; i++) {
			System.out.println(Thread.currentThread().getName()+"正在输出：" + i);
		}
	}
}
```
```java
new Thread(new Runnable() {
	@Override
	public void run() {
		Random random = new Random();
		for (int i = 0; i < 10; ++i) {
			sleep(random.nextInt(1000));
			System.out.println(String.format("T%d : %d", tid, i));
		}
	}
}).start();
```
<!--more-->
# Thread中的方法
- start() : 启动
- setDaemon(boolean bool) ： 设置后台线程
- getName() : 获得当前线程名字
- setPriority(int value) : 设置线程优先级
- Thread.sleep(int value) : 休眠
- Thread.currentThread() : 获取当前线程
- Thread.yield() : 线程让步
- join() : 线程插队

# 同步
## 同步代码块
```java
synchronized(lock){
	操作共享资源代码块
}
```
其中lock是一个锁对象，锁对象可以是任意类型的对象，但多个线程共享的锁对象必须是唯一的

## 同步方法
```java
synchronized 返回值类型 方法名([参数1,....]){}
```

同步代码块的锁是自己定义的任意类型的对象，同步方法的锁当前调用该方法的对象，静态方法的锁是该方法所在类的class对象。
同步解决了安全问题，但降低了效率。

## 死锁

## 同步队列 BlockingQueue
是一个接口

|     | 抛出异常 | 特殊值 | 阻塞 | 超时 |
| - | - | - | - |- |
| 插入 | add(e) | offer(e) | put(e) |offer(e, time, unit) |
| 移除 | remove() | poll() | take() | poll(time, unit) |
| 检查 | element() | peek() | 不可用 | 不可用 |


# 多线程通信
- void wait() : 当前线程放弃同步锁并进入等待，直到其他线程进入此同步锁，并调用notify()方法，或notifyAll()方法唤醒该线程为止
- void notify() : 唤醒此同步锁上等待的第一个调用wait()方法的线程
- void notifyAll() : 唤醒此同步锁上调用wait()方法的所有线程

```java	
public class demo {
	public static void main(String[] args) {
		Storage st = new Storage();
		Input input = new Input(st);
		Output output = new Output(st);
		new Thread(input).start();
		new Thread(output).start();
	}
}

class Storage{
	private int[] cells = new int[10];
	private int inPos, outPos;
	private int count;
	public synchronized void put(int num) {
		try {
			while(count == cells.length) {
				this.wait();
			}
			cells[inPos] = num;
			System.out.println("在cells[" + inPos +"]中放入数据---" + cells[inPos]);
			inPos++;
			if(inPos == cells.length)
				inPos = 0;
			count++;
			this.notify();
		}catch(Exception e) {
			e.printStackTrace();
		}
	}
	
	public synchronized void get() {
		try {
			while(count == 0) {
				this.wait();
			}
			int data = cells[outPos];
			System.out.println("从celss["  + outPos + "]中取出数据" + data);
			outPos++;
			if(outPos == cells.length)
				outPos = 0;
		}catch(Exception e) {
			e.printStackTrace();
		}
	}
}
```

这个和操作系统里的pv操作是一样的。

# ThreadLocal 
- 线程局部变量。即使是一个static成员，每个线程访问的变量是不同的。
- 常见于web中存储当前用户到一个静态工具类中，在线程的任何地方都可以访问到当前线程的用户。
- 参考HostHolder.java里的users

# Executor
- 提供一个运行任务的框架。
- 将任务和如何运行任务解耦。
- 常用于提供线程池或定时任务服务

```java
ExecutorService service = Executors.newFixedThreadPool(2);
service.submit(new Runnable() {
	public void run() {
		for (int i = 0; i < 10; ++i) {
			Thread.sleep(1000);
			System.out.println("Execute %d" + i);
		}
	}
});
```

# Future
- 返回异步结果
- 阻塞等待返回结果
- timeout
- 获取线程中的Exception
```java
	public static void testFuture() {
		ExecutorService service = Executors.newSingleThreadExecutor();
		Future<Integer> future = service.submit(new Callable<Integer>() {
			@Override
			public Integer call() throws Exception {
				sleep(1000);
				// throw new IllegalArgumentException("一个异常");
				return 1;
			}
		});
		service.shutdown();
		try {
			System.out.println(future.get());
			// System.out.println(future.get(100, TimeUnit.MILLISECONDS));
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
```
